<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Gvr Unity SDK (一) —— 项目引入]]></title>
      <url>%2F2016%2F12%2F03%2FImport-gvr-unity-sdk-into-the-project%2F</url>
      <content type="text"><![CDATA[Google 为虚拟现实(VR)提供了两个虚拟现实（VR）平台：Cardboard，世界上最受欢迎和可访问的移动VR平台，以及Daydream,一个用于低延迟，沉浸式和交互式移动VR的新平台。Google VR SDK包括您为这些平台开发所需的一切内容，包括库，API文档，开发人员示例和设计指南。 平台分类 Gooogle VR 官方页面为我们开发VR应用，提供了4种Api: Unity: Google VR SDK for Unity，允许您轻松地适应现有的Unity 3D应用程序的虚拟现实或从头开始构建自己的VR体验。支持Daydream和Cardboard Android: Google VR SDK for Android ，让您创建应用程序，显示3D场景与双目渲染，呈现空间音频，跟踪和反应头部运动，并与应用程序交互。支持Daydream和Cardboard iOS: Google VR SDK for iOS，可让您在Objective-C中为本地iOS应用程式建立VR体验。支持Cardboard Unreal Engine4: 虚幻引擎4原生支持Google VR，允许您使用新的和现有的UE4项目构建移动VR体验。支持Daydream和Cardboard 我们可以根据自己的需求选择合适的平台API，本文将开始介绍Unity平台Daydream SDK的相关使用。 Gvr for Unity 包含了什么？Unity对Google VR的原生支持，使其更容易去: 从头开始一个新的VR Unity项目 将现有的Unity 3D应用程序适配到VR 创建一个可以轻松切换进入和退出VR模式的应用程序 与Google VR的集成，提供了： 用户头部跟踪 并排立体渲染 检测用户与系统的交互（通过触发器或控制器） 用于特定VR查看器的自动立体声配置 VR观看者镜头的失真校正 当您将手机插入到查看器中时，可以使用对齐标记来帮助将屏幕置于镜头下方 自动陀螺漂移校正 Unity的Google VR SDK具有以下额外功能： 白日梦控制器支持 空间化音频呈现 一个简单的标线预制和相关脚本，用于基于凝视的用户交互 VR模拟在Unity编辑器的播放模式，使用鼠标和alt /控制键平移或倾斜摄像头 一个“头显演示”场景显示一个简单的纸板游戏，和一个“控制器演示”场景集成了白日梦控制器 FPS显示预览，显示应用程序的呈现性能 下载、安装UnityGoogle VR Unity 版本的SDK请求 Unity开发工具是5.2.1或者更高版本 以下提供最新Unity开发工具(5.4.2F2-GVR12)下载和gvr-unity-sdk下载: Windows :下载 OS X :下载 gvr-unity-sdk: 下载 (在此就不细说具体安装过程了，如果安装过程遇到了问题可以在本文底部留言） 项目引入首先我们解压我们下载的gvr-unity-sdk，然后打开Unity工具，点击右上角的NEW创建一个新的项目，填入项目名和保存路径 点击Create project后，该窗体关闭，稍等片刻将会打开主窗体,如果过程没有什么问题，将会是下面这样 在上半部分的左侧是Hierarchy,默认包含了场景名称，及其下面的Main Camera(主相机)，Directional Light（方向灯） 然后，我们看到下半部分左侧的Project窗口，然后选中Assets，鼠标右键 ==&gt; Import Package==&gt;Custom Package，找到之前解压的gvr-unity-sdk，打开其中的GoogleVRForUnity.unitypackage文件 然后弹出一个对话框，需要我们导入需要的文件，这里我只会用到Android平台，所以我取消选中Plugin下面的iOS、x86和x86_64，其他的都选中，然后点击Import导入 然后又会弹出一个对话框，需要导入包，然后继续点击Import Package 再次点击下一个对话框的Import 至此，完成了gvr-unity-sdk的项目导入，将会在Project窗口下看到Asstes下的两个根文件:Google VR 和 Plugin 及其它们的子文件 本节gvr-unity-sdk项目导入相关内容到此结束，下一节继续《Gvr Unity SDK (二) —— 创建GameObject》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最后的Android7.1开发者预览版升级]]></title>
      <url>%2F2016%2F11%2F23%2Ffinal-update-to-android-7-1-developer-preview%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Final update to Android 7.1 Developer Preview 今天我们推出了升级到Android 7.1开发者预览版 —— 我们发布最终版Android7.1.1平台到生态系统之前的最后一次。Android7.1.1包括了在Pixel和Pixel XL设备已经可以使用到的功能特性，并且添加了基于Android7.1平台的优化和首要错误修复。开发者预览版2，您能够确保您的应用已经为Android 7.1.1做好了准备，消费者将很快在他们的设备上运行它。 正如十月的时候强调的,我们也扩张了设备范围，您能够在Nexus 5X,Nexus 6P,Nexus 9和Pixel C设备上收到开发者预览版的升级。 如果有一部被受支持的设备，并且在Android测试计划已经注册，您将会在接下来的一周收到开发者预览版2的升级。如果您还没有注册您的设备，请访问站点注册您的设备并获取升级。 在12月初，我们将推出Android 7.1.1到全系列支持的设备以及Pixel和Pixel XL设备。 更新升级了什么？开发者预览版2是Android 7.1.1的发布候选者，您可以用它来完成您的应用程序开发，并测试准备即将到来的最终版本。其中包括了接近最终系统的行为和UI，以及整个系统和Google应用程序的最新错误修复和优化。 它也包括了在开发者预览版1中已经介绍过的开发者功能特性和APIs(API Level 25)，如果您还没有探索开发者功能特性，您将需要查看应用快捷方式，圆形图标资源和图片键盘支持等，您可以在此处查看开发人员功能的完整列表。 开发者预览版2 ，我们也升级了Android Studio中的 SDK 构建和平台工具。Android 7.1.1平台和API等级25模拟器系统镜像。最终版版本的支持库(25.0.1)也是可以使用的了，对于您去添加图片键盘支持,底部导航栏以及其他特性，去运行在API等级25或者更早期的设备。 对于API等级25更详细的检出在开发者预览版站点的API不同点和已经更新升级过的API参考 为您的应用准备7.1现在是时间去优化您的应用了，看起来最好的Android7.1.1。对于获得开始，升级到Android Studio2.2.2，然后通过Android Studio里面的SDK管理器下载API等级25平台，模拟器系统镜像，和工具。 安装API 等级25 SDK 之后，您能够升级的您的项目的compileSdkVersion到25去编译构建和测试新的APIs,如果您在做兼容性测试，我们建议升级您的应用的targetSdkVersion到25，利用兼容性行为禁用去测试您的应用。针对于如何去利用API等级25SDK去设置您的应用的详细过程，查看预览版建立 如果您在添加应用快捷方式或者圆形桌面图标到您的应用，您能够使用Android Studio的built-in Image Assets Studio去快速帮助您创建不同大小的图标，参见Material Design设计向导。您能够在API等级为25的Google APIs模拟器上面去测试您的圆形图标，包括圆形图标和新的Google Pixel桌面的支持。 如果您在添加图片键盘支持，您能够使用包括在预览版系统镜像中的Messenger和Google键盘应用去测试，因为它们包括对这个新API的支持。 使用Firebase Test Lab for Android扩展测试为了帮助扩展测试，确保利用Firebase Test lab for Android在云端进行测试。在预览期间不对所有虚拟设备,包括开发者预览版2(API25)进行收费。您能够使用自动爬行(Robo Test)去测试您的应用，不需要去写任何的测试脚本，或者您能够上传您自己仪器(例如:Espresso)测试，您能够在这儿上传您的测试。 将您的应用程式发布到Google Play的Alpha，Beta或制作频道在您完成了最终版的测试，您能够发布您编译的更新和可选择定位，API25到Google Play。您能够在Google Play Consolez中发布到您的alpha,beta,或者甚至制作通道，推送您的应用更新升级到那些运行Android 7.1用户的设备上，比如Pixel和Android Beta设备。 在您的合格设备上获取开发者预览版2如果您有符合资格的设备已注册Android Beta Program，设备将会在记下来的一周获得开发者预览版2的更新升级。您无须任何操作。如果您还没有注册计划，最简单的方式就是通过访问android.com/beta选择您合格的Android电话或者平板 ——— 您将会不久会收到这个预览版OTA升级。一如既往，您也能够下载并手动刷入这个更新升级 正如刚才提到的,这个开发者预览版更新对于Nexus 5X, Nexus 6P, Nexus 9, 和 Pixel C devices都可用。 我们期望从12月开始，在短短几个星期内推出Android 7.1.1的最终版本，我们将推出Android 7.1.1到全系列支持预览版的设备，以及最近推出的Pixel和Pixel XL设备。那时候，我们还会将来源码推送到AOSP，因此我们的设备制造商合作伙伴可以在其设备上向消费者提供此新平台更新。 与此同时，我们继续欢迎您在开发者预览版 issue 追踪、N预览版开发者社区或者Android Beta社区的反馈，因为我们正在努力争取在12月的最终消费者发布！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Firebase特性之Robo测试实验室]]></title>
      <url>%2F2016%2F11%2F06%2Fandroid-in-firebase-robo-test-lab%2F</url>
      <content type="text"><![CDATA[上一篇我们讲到了《Firebase特性之崩溃报告》，在这篇文章中，我们来共同学习一下如何在Androids上使用Firebase的测试实验室。 测试前的准备要在Androids上使用Firebase的测试实验室，首先要做的就是参照上一篇的内容，如果你之前在Firebase上创建过项目可以跳过继续直接进行后面下一步步骤；或者也可以在本地用Android Studio创建一个新的项目，参照上一篇的配置配置好本地和Firebase云端环境，当你本地Android Studio环境和Firebase云端空间项目都创建成功后，确保本地项目已经添加了google-services.json文件和相关依赖，就可以开始下一步操作。 选择测试项目 点击左侧的Test Lab 在Androids上使用Firebase的测试实验室,然后点击RUN YOUR FIRST TEST按钮 选择测试类型当前页面会提示让你选择测试类型,有两种类型: Robo测试 Robo测试在各种设备上自动探索您的应用程序，以查找缺陷并报告发生的任何崩溃。 Robo测试不需要你编写应用测试。 仪器测试 运行您编写的Espresso，Robotium或UIAutomator 2.0测试，以在各种设备上测试您的应用程序。 Robo测试与使用Android UI框架中的元素的应用兼容：如果您的应用程序使用其他UI框架（如Unity），测试可能只会探索您的应用程序的第一个屏幕。你可以点击查看更多 本节我们来总结类型之一的Robo测试的相关使用 Robo测试配置测试我们选择默认的Robo测试，然后点击CONTINUE继续 这里需要上传应用的APK文件，然后选取您要测试的尺寸。 等待上传成功…… 上传成功后，点击CONTINUE继续 这里选择你想测试的设备、API等级、方向、和地区，每一个尺寸你必须至少要选择一个，然后点击当前页面右下角的START XX TESTS按钮。（示例：我这里选择了虚拟设备Nexus 5、API Level 23(Android 6.0.x)、方向横屏和竖屏、地区美国（en_us） ） 开始测试下面开始进入Robo测试界面，开始测试上面我配置的示例，然后等待测试结果: 等待几分钟，然后测试完成了，２个pass,都通过了： 分析测试然后我们点开测试配置的,其中一个设备进去，可以看到一些测试的详细的信息(测试结果、测试时间、测试用时、地区、方向),重点是下面的LOGS、SCREENSHOTS、ACTIVITY MAP、VIDEO LOGS 测试时打印的日志 SCREENSHOTS 测试时屏幕截图 ACTIVITY MAP Activity 地图 VIDEO 视频记录的测试过程 下面是视频对应的gif动态图效果（ps:图片是720x1280的，有点大，可以点击下面的图片，查看效果）: 最后我们点击详细页面右上角的VIEW SOURCE FILES，可以查看源文件，是放在Google云平台的 以上简单的介绍了如何使用Firebase实验室Robo测试类型的相关内容，有关Firebase的其他特性，后续总结。如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Firebase测试实验室里的Android开发者预览版]]></title>
      <url>%2F2016%2F11%2F05%2Fandroid-dev-preview-in-firebase-test-lab%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Test on Android 7.1 Developer Preview in Firebase Test Lab 为了提供最好的用户体验的大门，对于Android的Firebas测试实验室允许您测试您的应用以确保它们在多个设备配置兼容。跨越系统版本、屏幕方向和地区，点击一次，您就能够在Google云的上百台设备配置上运行您的测试，并且您能给很快的收到结果。 今天，我们非常激动的宣布Android 7.1 开发者预览版在Firebase测试实验室虚拟设备可以用了。除了使用Android Beta方案在您的物理设备上测试Android 7.1开发者预览版本，或者是在您本地Android模拟器上，您还可以使用Firebase测试实验室将应用测试扩展到上百个Android虚拟设备。 您也能够使用Firebase测试实验室来执行自己的测试。如何您还没有一个任意的测试脚本，Robo测试是在新平台上进行基本兼容性测试的理想选择。它会抓取您的应用程序，以尝试找到崩溃。您也可以在Android Studio中利用Espresso 测试记录器去记录自己的仪器测试，而无需编写任何代码。 从现在起至12月底（2016年12月31日），Firebase测试实验室将会在Firebase Blaze计划上，对所以虚拟设备免费提供，以此帮助您确保您的应用程序和Android 7.1开发者预览版兼容，以及与其他Android版本。 为您的应用API 等级25做准备，然后去Firebase测试实验室控制台运行您的第一个测试。 测试愉快！ (Robo测试揭开Flood-It！应用在Android 7.1开发者预览中的崩溃) 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的AES加密解密技术]]></title>
      <url>%2F2016%2F11%2F03%2FAES-in-Android%2F</url>
      <content type="text"><![CDATA[最近需要在项目中加密数据，首先想到要使用到AES加密技术。在网上找了很多，都是适合Java工程，在Android上无法正常达到预期的解密。花了两天的时间终于找到了可以在Android上顺利实现加密解密的代码，在这里有必要的记录一下。 简介对于AES的概念，以下摘自维基百科，它是这样解释的: 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 其余的就不多说了，以下直接进入主题 … Android中的用法以下示例是基于Android的，Java不通用 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.wt.aes;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * Created by shoewann on 16-9-23. */public class AESUtils &#123; public static String encrypt(String seed, String cleartext) throws Exception &#123; byte[] rawKey = getRawKey(seed.getBytes()); byte[] result = encrypt(rawKey, cleartext.getBytes()); return toHex(result); &#125; public static String decrypt(String seed, String encrypted) throws Exception &#123; byte[] rawKey = getRawKey(seed.getBytes()); byte[] enc = toByte(encrypted); byte[] result = decrypt(rawKey, enc); return new String(result); &#125; private static byte[] getRawKey(byte[] seed) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); SecureRandom sr = SecureRandom.getInstance("SHA1PRNG", "Crypto"); sr.setSeed(seed); kgen.init(128, sr); // 192 and 256 bits may not be available SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded(); return raw; &#125; private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125; private static String toHex(String txt) &#123; return toHex(txt.getBytes()); &#125; private static String fromHex(String hex) &#123; return new String(toByte(hex)); &#125; private static byte[] toByte(String hexString) &#123; int len = hexString.length() / 2; byte[] result = new byte[len]; for (int i = 0; i &lt; len; i++) result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue(); return result; &#125; private static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private final static String HEX = "0123456789ABCDEF"; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125;&#125; 示例调用12345678910111213141516171819202122232425262728293031323334package com.wt.aes;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;/** * Created by shoewann on 16-9-23. */public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; String content="我是需要加密的数据内容"; String key="com.sina.com"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try &#123; Log.d(TAG,"加密前："+content); //encrypt （加密） String encrypt = AESUtils.encrypt(key, content); Log.d(TAG,"加密后："+encrypt); //decrypt （解密） String decrypt = AESUtils.decrypt(key, encrypt); Log.d(TAG,"解密后："+decrypt); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.d(TAG,"ERROR："+e.getMessage()); &#125; &#125;&#125; 运行结果,如果是这样: 根据以上log信息可以看出，数据能在设备上成功被加密和解密出来，说明你当前的调试设备版本在Android 7.0(API 24)以下，你依然可以使用以上的方式来加密解密。 Android N 已弃用Crypto 如果你在Android系统版本是7.0的设备上运行以上代码，结果是这样的: 根据以上的log信息可以看出，在Android 7.0 新版本 Android SDK 不再支持 Crypto,至于详细可以访问http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html或者查看之前我翻译提交的这篇文章。 以下是，修改过后的工具类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.wt.aes;import java.nio.charset.StandardCharsets;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * Created by shoewann on 16-9-23. */public class AESUtils &#123; public static String encrypt(String seed, String cleartext) throws Exception &#123; byte[] rawKey = deriveKeyInsecurely(seed,32).getEncoded(); byte[] result = encrypt(rawKey, cleartext.getBytes()); return toHex(result); &#125; public static String decrypt(String seed, String encrypted) throws Exception &#123; byte[] rawKey = deriveKeyInsecurely(seed,32).getEncoded(); byte[] enc = toByte(encrypted); byte[] result = decrypt(rawKey, enc); return new String(result); &#125; private static SecretKey deriveKeyInsecurely(String password, int keySizeInBytes) &#123; byte[] passwordBytes = password.getBytes(StandardCharsets.US_ASCII); return new SecretKeySpec( InsecureSHA1PRNGKeyDerivator.deriveInsecureKey( passwordBytes, keySizeInBytes), "AES"); &#125; private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception &#123; SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125; private static String toHex(String txt) &#123; return toHex(txt.getBytes()); &#125; private static String fromHex(String hex) &#123; return new String(toByte(hex)); &#125; private static byte[] toByte(String hexString) &#123; int len = hexString.length() / 2; byte[] result = new byte[len]; for (int i = 0; i &lt; len; i++) result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue(); return result; &#125; private static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private final static String HEX = "0123456789ABCDEF"; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125;&#125; 以上的工具类中InsecureSHA1PRNGKeyDerivator这个类，可以在示例代码里找到 通过再次调用以上的工具类中的加密解密的方法，就可以在Android 7.0上成功加密解密出数据: 以上是对Anroid 中使用AES及在7.0上使用相关问题，原创不易，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[终止Eclipse作为Android开发工具的支持]]></title>
      <url>%2F2016%2F11%2F03%2Fsupport-ended-for-eclipse-android%2F</url>
      <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Support Ended for Eclipse Android Developer Tools 随着Android Studio 2.2的发布，现在是时候与Eclipse Android开发工具说再见了。我们正式结束了对它们的支持和开发。从未有过更好的时间切换到Android Studio,体验我们对Android开发工作流程的改进。 Android StudioAndroid Studio，是Android官方的IDE工具，功能强大的代码编辑与高级代码完成和重构。它包括了强大的静态分析,将Android工程团队的智慧带给您，帮助您轻松应用Android编码最佳实践,并且包括在Java和C++同时调试以帮助修复任何漏洞。当您将其与性能工具相结合时，一个快速、灵活的构建系统、代码模板、GitHub集成、及其高性能、功能丰富的模拟器，您将获得针对操作系统对于许多形状因素进行深入Android定制的开发环境。它是在Google Play前125个应用和游戏中的92％被使用的开发环境，我们不断创新，以处理每一个Android开发需求。 Android Studio 2.2中有什么新东西Android Studio 2.2是来源与Android Studio 2.0伟大的功能进行构建的。这里超过20种新功能去改进开发，无论您是设计，迭代还是测试，值得注意的变化包括: Instant Run - 超快速迭代引擎现在更可靠，可用于更多类型的更改 Layout Editor - 新的用户界面设计器，比以往更容易创建漂亮的应用程序体验 Constraint Layout - 用于构建动态用户界面的新的灵活布局引擎 - 设计用于使用新的布局编辑器 C++ Support - 现在支持CMake和ndk-build以及改进的编辑和调试体验 APK Analyzer - 检查APK以帮助您简化APK并调试multi-dex问题 GPU Debugger(beta) - 捕获OpenGL ES命令流，并使用GPU状态检查重播它们 Espresso Test Recorder(beta)- 记录与您的应用程序的互动，并输出UI测试代码 对于我们的ADT粉丝所有您喜欢的ADT工具现在是Android Studio的一部分，包括DDMS、Trace Viewer、Network Monitor、和CPU Monitor，我们还改进了Android Studio的辅助功能，包括键盘导航增强和屏幕阅读器支持。 在2015年结束的时候就已经宣布了终止Eclipse作为Andorid开发工具(ADT)的开发和官方支持。包括了Eclipse ADT插件和Android Ant 构建系统。通过Studio的最新更新，我们完成了转换。 迁移到Android Studio开始,下载和安装 Android Studio,对于大多数的开发者，包括那些具有C / C++项目。迁移与导入现有Eclipse ADT项目一样简单，在Android Studio中使用File &gt; New&gt; Import Project菜单选项,有关迁移过程的详细信息，请参阅迁移指南。 反馈和开源贡献我们致力于使Android Studio成为构建Android应用程序的最佳集成开发环境,因此如果有缺少功能或其他挑战，阻止您切换到Android Studio，我们想听听[调查]！您还可以直接向团队提交错误或功能请求，并通过我们的Twitter或Google+帐户通知我们。 Android Studio是一个开源项目，所有的免费提供。如果您有兴趣贡献或学习更多，请查看我们的开源项目页面。 以上是对Anroid 官网博客文章的部分翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 7.1 应用快捷键详解]]></title>
      <url>%2F2016%2F10%2F21%2Fandroid71-dev-preview-app-shortcuts%2F</url>
      <content type="text"><![CDATA[上一篇讲到了Android 7.1的预览版发布，今天这篇来说说其中的App Shortcut的使用。 Android 7.1允许在你的应用中定义具体动作的快捷键，这些快捷键能够被支持显示到launcher桌面上。比如说Nexus 和Pixel设备上已经提供了这个了。快捷键能让你的用户快速在你的应用中开始一个通用的或者建议的任务。 每一个快捷键引用了一个或者更多的intent,当用户在你的应用中选择了快捷键，每一个都会启动一个具体的动作。你能够表现出来的动作示例包括如下这些： 在一款地图类应用中导航用户去一个特定的位置 在一款社交类应用中发送消息给一个朋友 在一款媒体类应用中播放下一集电视剧 在一款游戏类应用中加载最后一次保存的游戏进度 你能够在你的应用中发布两种不同类型的快捷键： 静态快捷键定义在一个资源文件中，打包到一个APK中，因此，你必须等到你的应用直到更新升级整个应用，才能去改变这些静态快捷键的详细内容。 动态快捷键在运行时使用ShortcutManager API发布，在运行的过程中，你可以去发布、更新、移除它的快捷键。 你能够在你的应用中一个时间里发布5个快捷键（静态快捷键和动态快捷键结合在一起）。用户，然而，能够复制应用的快捷键到launcher桌面上，创建一个固定的快捷键。用户能够在你的应用中创建和访问一个没有限制数量大小的固定快捷键和触发动作。你的应用不能够移除这些快捷键，但是能够禁用它们。 注意： 虽然其他的应用不能够访问在你快捷键中的元数据，launcher桌面它自己能访问这个数据，因此，这些元数据应该隐藏敏感的用户信息。 静态快捷键静态快捷键应该在你的应用内部提供一个链接去生成动作，这些动作应该和你应用的当前版本的生活时间保持一致。对于静态快捷键较好的候选包括查看已发送的信息、设置一个闹钟和显示一个用户一天的锻炼活动。对于创建一个静态的快捷键，完成如下的顺序步骤: 1、在你应用的manifest文件(AndroidManifest.xml)中找到一个activity的intent filtes，action是设置的andorid.intent.action.MAIN并且category是设置的android.intent.category.LAUNCHER 2、添加一个节点到这个activity，引用在应用中定义的快捷键资源文件: 12345678910111213141516171819&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;!-- 添加如下代码 --&gt; &lt;meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts" /&gt; &lt;!--添加如上代码--&gt; &lt;/activity&gt; &lt;/application&gt; 3、创建一个新的资源文件（res/xml/shortcuts.xml）,这个文件就是定义在应用的manifest的快捷键 4、在这个新的资源文件中，添加一个根节点，包含了一个的list集合节点。每一个节点中包含了关于一个静态快捷键的信息，包括它的图标、它的描述、和它在应用内部启动的intent意图: 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shortcuts xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;shortcut android:shortcutId="id0" android:enabled="true" android:icon="@mipmap/ic_launcher" android:shortcutShortLabel="@string/shortcutShortLabel" android:shortcutLongLabel="@string/shortcutLongLabel" android:shortcutDisabledMessage="@string/shortcutDisabledMessage"&gt; &lt;intent android:action="android.intent.action.VIEW" android:targetPackage="com.xw.appshortcuts" android:targetClass="com.xw.appshortcuts.MainActivity" /&gt; &lt;categories android:name="android.shortcut.conversation" /&gt; &lt;/shortcut&gt; &lt;!-- 这里指定更多的快捷键 --&gt;&lt;/shortcuts&gt; 以下是对上面的shortcut标签相关属性的解释： shortcutId, 表示唯一的id enabled, 表示这个shortcut是否可用 shortcutShortLabel, 这里是配置的短名称, 下面还会有长名称, 如果长名称显示不下, 就显示短名称 shortcutLongLabel, 这里是配置的长名称, launcher会优先选择长名称显示 shortcutDisabledMessage, 这个配置是在我们选择一个不可用的shortcut时给用户的一个提示 动态快捷键动态的快捷应该在你的应用内部提供一个具体的链接，上下文敏感动作。这些动作能够在用户使用你的应用中进行改变，并且他们甚至能够在当你的应用运行的时候进行改变。对于动态快捷键较好的候选包括打电话给某一个人、导航到一个固定的位置、和查看一款固定游戏当前的分数。 这个ShortcutManager API允许你完成如下的动态快捷键操作: 发布：使用setDynamicShortcuts(List))去重新定义动态快捷键实体类集合，或者使用addDynamicShortcuts(List))去增加一个已经存在的动态快捷键集合。 更新：使用updateShortcuts(List))方法。 移除：移除一个设置的动态快捷键使用removeDynamicShortcuts(List))，或者使用removeAllDynamicShortcuts())方法去移除所有的动态快捷键。 具体示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.xw.appshortcuts;import android.content.Intent;import android.content.pm.ShortcutInfo;import android.content.pm.ShortcutManager;import android.graphics.drawable.Icon;import android.net.Uri;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private List&lt;ShortcutInfo&gt; shortcutInfos;//快捷键集合 private String[] shortLabel = null;//每个快捷键的短名称 private String[] longLabel = null;//每个快捷键的长名称 private String[] url = null;//每个快捷键的意图跳转域名 private int[] icon = null;//每个快捷键的图标 //============================================ private ShortcutManager shortcutManager = null; private Button setDynamicShortcuts = null;//加载动态快捷键的按钮 private Button disableShortcuts = null;//禁用移除快捷键的按钮 private Button updateShortcuts = null;//更新快捷键的按钮 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; /** * 初始化视图 */ private void initView() &#123; this.updateShortcuts = (Button) findViewById(R.id.updateShortcuts); this.disableShortcuts = (Button) findViewById(R.id.disableShortcuts); this.setDynamicShortcuts = (Button) findViewById(R.id.setDynamicShortcuts); this.updateShortcuts.setOnClickListener(this); this.disableShortcuts.setOnClickListener(this); this.setDynamicShortcuts.setOnClickListener(this); &#125; /** * 初始化数据 */ private void initData() &#123; shortcutManager = getSystemService(ShortcutManager.class); shortLabel = new String[]&#123;"Google", "Youtube", "Facebook", "Twitter"&#125;; longLabel = new String[]&#123;"Open Google", "Open Youtube", "Open Facebook", "Open Twitter"&#125;; url = new String[]&#123;"https://www.google.com/", "https://www.youtube.com/", "https://www.facebook.com/", "https://www.twitter.com/"&#125;; icon = new int[]&#123;R.mipmap.ic_google,R.mipmap.ic_youtube,R.mipmap.ic_facebook,R.mipmap.ic_twitter&#125;; &#125; /** * 设置动态快捷键 */ private void setDynamicShortcuts() &#123; shortcutInfos = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; shortLabel.length; i++) &#123; ShortcutInfo shortcut = new ShortcutInfo.Builder(this, String.valueOf(i)) .setShortLabel(shortLabel[i]) .setLongLabel(longLabel[i]) .setIcon(Icon.createWithResource(this, icon[i])) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(url[i]))) .build(); shortcutInfos.add(shortcut); &#125; shortcutManager.setDynamicShortcuts(shortcutInfos); &#125; /** * 禁用并移除快捷键 */ private void disableShortcuts() &#123; List&lt;ShortcutInfo&gt; list = shortcutManager.getPinnedShortcuts(); if (list != null) &#123; for (ShortcutInfo info : list) &#123; //移除下标为0的快捷键 if (info.getId().equals("0")) &#123; shortcutManager.disableShortcuts(Collections.singletonList(info.getId()), "快捷方式已无效,请手动删除"); shortcutManager.removeDynamicShortcuts(Collections.singletonList(info.getId())); &#125; &#125; &#125; &#125; /** * 更新快捷键 * @param index */ private void updateShortcuts(int index) &#123; ShortcutInfo info = new ShortcutInfo.Builder(this, String.valueOf(index)) .setShortLabel("GitHub") .setLongLabel("Open GitHub") .setIcon(Icon.createWithResource(this, R.mipmap.ic_github)) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.github.com"))) .build(); shortcutManager.updateShortcuts(Collections.singletonList(info)); &#125; /** * 点击事件 * @param view */ @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.setDynamicShortcuts: setDynamicShortcuts(); break; case R.id.disableShortcuts: disableShortcuts(); break; case R.id.updateShortcuts: updateShortcuts(0); break; default: break; &#125; 运行效果： 动态增加快捷键: (长按图标弹出) (将每一个快捷键拖出来固定到桌面) (固定到桌面的和快捷键集合弹出) 动态更新快捷键: (更新Google为==&gt;GitHub) 动态禁用移除快捷键: (禁用GitHub) 系统代码结构 通过sdk下的hierarchyviewer工具，可以看到长按桌面图标弹出的部分是一个DeepShortcutsContainer,其中包括了一个白色箭头的View和显示每一个快捷键的条目DeepShortcutsView组成。每一个DeepShortcutsView快捷键item又是由一个显示图标的View和一个DeepshortcutsTextView组成。 以上就是简单的对Android 7.1上面App Shortcut方面的概括总结，部分内容源于官方文档，如有不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[现在可用：Android 7.1开发者预览版]]></title>
      <url>%2F2016%2F10%2F20%2Fandroid71-dev-preview-available%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Now available: Android 7.1 Developer Preview 几周以前我们宣布Android 7.1 开发者预览版已经在准备中了。今天你可以通过下载SDK和工具获得这个新的发布。对于获取到7.1发布在你的合格手机上面，你的设备在Android Beta program上注册。如果你的设备已经注册了，你将会收到自动升级。 开发者预览版中有什么？Android 7.1开发者预览版给你一切需要在这个新的平台上测试你的应用，或者使用新的功能特性扩展延伸它，像应用快捷方式和图像键盘的支持。它包括一个升级的SDK和工具、文档和示例，以及模拟器和设备镜像对于运行你的应用在已经支持的设备上。 我们继续使用像在N和更早发布的模型，Android7.1是一个增量升级，这儿有一些不同的亮点： 既然7.1已经在Pixel上面被启动了，我们对于Nexus系列设备在测试质量方面进行最初的开发者预览版传送，我们的目标是梳理出任何设备特定问题。 我们最终新的API版本为API 等级25 我们把应用目标新的API公开发布在Google Play，这样你就可以更新你的应用程序只要你准备好了。 最初的预览版之后，我们计划在11月会传送一个升级，紧接着是最终版公开发布到Android开源项目(AOSP)在12月，最初可以在Nexus 5x,Nexus 6P 和 Pixel C设备上使用，我们将在11月去扩展开发者预览版到其他设备。 为你的应用获取Android 7.1做准备开始，升级到Android Studio 2.2.2并下载API Level 25 platform,emulator system images 和 tools.在Android Studio中通过SDK Manager可以下载最终版本的API Level 25 SDK 可用。 一旦你安装了API Level 25 SDK,你就能够升级的的项目的compileSdkVersion到25去构建和针对这个新版APIs测试.如果你在进行兼容性测试，我们建议你升级你的应用的targetSdkVersion到25去测试你的应用测试禁用的兼容性行为。对于如何去建立你的应用使用API 25 SDK ,看建立预览 如果你添加了应用快捷键或者圆形桌面icon到你的应用，你可以使用Android Studio的 built-in Image Asset Studio 去快速帮你创建不同大小的icons,见Material Design向导 Google APIs模拟器镜像伴随着Android API Level 25的sdk，包括圆形icons的支持和全新Google Pixel 启动器，Google API 系统镜像允许你在支持环形图标的设备上，去测试你的应用的圆形应用图标看上去怎么样。同时，如果你正在开发动态壁纸，你也能够使用新的系统镜像在Android 7.1的模拟器上去测试增强预览版元数据。 对于帮助你添加图像键盘的支持，你能够使用Messager和Google 键盘应用被包括在预览版的系统镜像中去测试，作为它们包括这个新的API的支持。 伴随着API Level 25的SDK，我们也要升级Android Support Library到25.0.0，，这个新的版本让你添加图像键盘的支持向后兼容到API Level 13。它也介绍了BottomNavigationView 小部件，从材料设计想到去实现bottom navigation pattern. 在API Level 25上面的详细检出API diffs和已更新的API refenrence在developer preview site 在Google Play上发布你的应用到alpha,beta或者production通道既然Android 7.1是最终版，你能够发布更新兼容，目标可选，API 25到Google Play.你现在能够发布应用升级，使用API 25到在Google Play Developer Console上你的alpha,beta,或者甚至是production通道。通过这种方式，推送你的应用升级给那些运行在Android 7.1设备上的用户，比如Pixel和Android Beta设备。 在你合格的设备上如何获取Android 7.1开发者预览版如果你已经在Android Beta program注册了,你的合格的设备将会马上收到Android 7.1开发者预览版升级，在你那边不需要做任何操作。如果你还没有在Android Beta上注册，最简单的开始方式是访问android.com/beta,并选择你合格的Android 电话或者平板——你将不久会通过云端收到这个(或者晚点)预览版升级。如果你已经注册的设备并且不想接收到这个升级，仅仅是访问Android Beta和取消注册这个设备。你也能够下载并手动的刷入这个升级 我们欢迎你反馈在开发者问题跟踪、N 开发者预览版社区、或者是Android Beta 社区作为我们工作，朝向在11月的消费者发布。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[即将到来：Android 7.1 开发者预览版]]></title>
      <url>%2F2016%2F10%2F12%2Fandroid-71-developer-preview%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Coming soon: Android 7.1 Developer Preview 今天，我们包装最终平台版本Android 7.1牛轧糖。你可能在上周的活动中已经先睹为快了。它是依赖于Android 7.0增加升级的，但是对于消费者和开发者来说包含了新的功能特性——从平台对Daydream VR的支持，到A/B系统升级，再到App快捷方式和图像键盘支持。 我们已经一直与设备制造商密切合作，让他们为Android 7.1做准备，接下来我们会给您可以访问此更新，你就可以开始让你的应用做好准备。 本月晚些时候，我们将把Android 7.1平台作为一个开放开发者预览版带给你，类似于我们之前对Android7.0所做的那样。你将能够在这个新的平台上面进行测试和编译，尝试最终功能特性。 和往常一样，我们讲通过Android Beta Program进行开发者预览版的传递，这样使得参与它更加令人难以置信的容易。 在Android 7.1中是什么？Android 7.1提供生产率、安全和Android 7.0的性能、伴随着各种优化和Bug修复、功能特性以及新的APIs(API Level 25) 对于开发者来说，Android 7.1添加了新的功能来帮助你紧密结合的驱动和传递，提高用户的体验，比如： App快捷方式API—— 让你能够直接在Launcher桌面进行按键操作，并带领你的用户瞬间深度的进入你的应用。你能够创建多达5个快捷方式，无论是静态的或是动态的。 圆形应用图标支持—— 让你提供精美漂亮的圆角图标资源，看上去匹配Pixel和其他launcher 增强的动态壁纸元数据—— 让你提供有关您的动态壁纸，以此来作为壁纸预览显示任何选择器的元数据。你能够显示已存在的元数据，比如标签、描述、和作者，还有一个新的上下文URL和标题链接到更多的信息。 Android 7.1也还增加了这些备受开发商要求的功能平台: 图像键盘支持 —— 用户可以从自己的键盘输入的内容，让他们表达自己通过定制贴纸，GIF动画等来扩展内容类型。应用程序可以告诉他们接受什么类型的内容键盘，键盘可以提供所有他们提供给用户的图片和其他内容。对于广泛的兼容性，这个API也将在支持库可用。 存储管理器意图 —— 让一个应用带领用户朝向一个新的设置屏幕去清理没有使用的文件，并释放设备上的存储空间。 对于运营商和呼叫应用，这个平台包括了新的APIs去支持多终端呼叫和新的电话配置选项 (App shortcuts) (Image keyboard support) 让您的应用做好准备Android 7.1是增量升级，但是它是一如既往的重要，确保你的应用看上去和运行都很棒——尤其是当设备已经开始接触到消费者了。 Android 7.1开发者预览版会给你，你需要利用它们的一切新的功能特性去测试你的应用程序或扩展，像快捷方式或者图像键盘。包括新APIs的SDK、编译工具、文档和示例，以及在已经支持的Nexus设备模拟器和设备系统镜像去运行你的应用。我们也将包括一个启动器和支持快捷方式的应用，一个键盘和支持图像键盘的应用。 如果你想自动接收到开发者预览版，访问Android Beta并注册你的设备，如果你的之前注册了一个设备并没有取消注册，你的设备将会收到升级。如果你已经注册了，但是你又不想接收升级，尽快访问Android Beta去取消设备注册。 最初，我们将提供开发者预览版给Nexus 5X, Nexus 6P, and Pixel C 设备，在预览结束扩展到其他支持的设备。在Android 7.1.x平台发布。由于在十二月初，我们将推出更新支持的设备 —— Nexus 6, 5X, 6P, 9, Player, Pixel C,支持 Android One devices —— 以及 Pixel 和 Pixel XL设备。 消费设备即将到来我们正在与我们的伙伴合作，将会在未来的几个月带着Android7.1给生态系统的设备，所以我们建议只要Android 7.1开发者预览版下载可用。测试您的应用程序的兼容性和优化它们,让它们看起来是最好的，比如通过提供圆形的应用程序图标，添加程序快捷方式。 同时，敬请关注，我们会尽快分享关于开发者预览版的更多详细信息！ 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中使用Nio通道与内存映射]]></title>
      <url>%2F2016%2F10%2F08%2Fandroid-nio-channel-operation-file%2F</url>
      <content type="text"><![CDATA[NIO 是non-blocking的简称，在jdk1.4 里提供的新api 。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)缓存支持。字符集编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。 在分析公司前辈写的项目，无意中发现了其中使用到了Java nio相关的东西。于是这几天就在学习Java nio，也看了Ron Hitchens著的《Java NIO》这本书。 复制文件先来看一个例子：以复制一个大小为2.5M的apk文件为例。 传统IO的方式 12345678910111213141516171819202122long startTime = System.currentTimeMillis();try &#123; FileInputStream input = new FileInputStream(sourceFile); BufferedInputStream inbuff = new BufferedInputStream(input); FileOutputStream out = new FileOutputStream(targetFile); BufferedOutputStream outbuff = new BufferedOutputStream(out); byte[] b = new byte[1024]; int len = 0; while ((len = inbuff.read(b)) != -1) &#123; outbuff.write(b, 0, len); &#125; outbuff.flush(); outbuff.close(); out.close(); inbuff.close(); input.close();&#125; catch (Exception ex) &#123; ex.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "传统IO方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:23.970 2575-2575/com.shoewann.demo D/MainActivity: 传统IO方式：耗时94ms 传统IO的方式：耗时94ms NIO通道的方式 12345678910111213141516171819202122long startTime = System.currentTimeMillis();try &#123; //文件(输入、输出) Stream流 FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(targetFile); //文件(输入、输出) Channel通道 FileChannel fcIn = fis.getChannel(); FileChannel fcOut = fos.getChannel(); //从文件输入通道传输byte数据到文件输出通道 fcIn.transferTo(0, fcIn.size(), fcOut); //关闭文件(输入、输出) Channel通道 fcOut.close(); fcIn.close(); //关闭文件(输入、输出) Stream流 fos.close(); fis.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "nio通道方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:26.103 2575-2575/com.shoewann.demo D/MainActivity: nio通道方式：耗时79ms NIO通道的方式：耗时79ms速度比传统IO的方式快，当然比起NIO通道复制，下面的这种内存映射的方式还更快 内存映射的方式 1234567891011121314151617181920212223242526long startTime = System.currentTimeMillis();try &#123; //创建源文件和目标文件的随机访问文件对象 RandomAccessFile raf = new RandomAccessFile(srcFile, "r"); RandomAccessFile wraf = new RandomAccessFile(targetFile, "rw"); //创建文件Channel通道 FileChannel in = raf.getChannel(); FileChannel out = wraf.getChannel(); //源文件的通道大小 long size = in.size(); //内存映射通道 MappedByteBuffer inBf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); //写入到输出通道 out.write(inBf); //关闭输入输出通道 in.close(); out.close(); //关闭随机访问文件对象 raf.close(); wraf.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; long endTime = System.currentTimeMillis() - startTime; Log.d(TAG, "内存映射文件方式：耗时" + endTime + "ms");&#125; 调用，输出： 110-08 21:09:28.168 2575-2575/com.shoewann.demo D/MainActivity: 内存映射文件方式：耗时35ms 内存映射的方式：耗时35ms 通过以上的示例，可以看出对文件进行复制操作，内存映射文件的方式是最快的，nio通道方式仅次其后，传统IO方式相对前面两种较慢。但是，内存映射文件和nio通道的方式都是基于传统IO的方式进行衍生而来。 读文件123456789101112RandomAccessFile rRaf = new RandomAccessFile(file, "r");FileChannel fcIn = rRaf.getChannel();long size = fcIn.size();int len = (int) file.length();byte[] bytes = new byte[len];MappedByteBuffer inBf = fcIn.map(FileChannel.MapMode.READ_ONLY, 0, size); for (int i = 0; i &lt; len; i++) &#123; bytes[i] = inBf.get(i);//取出每个元素&#125;String str = new String(bytes, "utf-8");fcIn.close();rRaf.close(); 写文件123456RandomAccessFile wRaf = new RandomAccessFile(file, "rw");FileChannel fcOut = wRaf.getChannel();//fcOut.position(fc.size()); // 移动到文件末尾，进行追加 fcOut.write(ByteBuffer.wrap(encrypt.getBytes()));fcOut.close();wRaf.close(); 以上就是Android中使用Nio通道与内存映射的示例，如有不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 7.0 应用之间的文件共享]]></title>
      <url>%2F2016%2F09%2F27%2Fandroid-n-sharing-files-between-apps%2F</url>
      <content type="text"><![CDATA[For apps targeting Android 7.0, the Android framework enforces the StrictMode API policy that prohibits exposing file:// URIs outside your app. If an intent containing a file URI leaves your app, the app fails with a FileUriExposedException exception.To share files between applications, you should send a content:// URI and grant a temporary access permission on the URI. The easiest way to grant this permission is by using the FileProvider class. For more information on permissions and sharing files, see Sharing Files. 以上是官方文档给出的介绍，大致意思也就是: 对于面向 Android N 的应用，Android 框架执行的 StrictMode API 政策禁止向您的应用外公开 file:// URI。 如果一项包含文件 URI 的 Intent 离开您的应用，应用失败，并出现 FileUriExposedException 异常。 若要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。 进行此授权的最简单方式是使用 FileProvider 类。 如需有关权限和共享文件的更多信息，请参阅共享文件。 1234567FileProviderpublic class FileProvider extends ContentProvider java.lang.Object ↳ android.content.ContentProvider ↳ android.support.v4.content.FileProvider 示例我们先来看看以下的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.xw.fileproviderdemo;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.support.v4.app.ActivityCompat;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private android.widget.Button btntakepic; private android.widget.ImageView imgshow; private static final int REQUEST_CODE_TAKE_PHOTO = 0;//拍照请求码 private static final int REQUEST_CODE_CLIP_PHOTO = 1;//裁剪请求码 private File mOutputFile; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.imgshow = (ImageView) findViewById(R.id.img_show); this.btntakepic = (Button) findViewById(R.id.btn_take_pic); this.btntakepic.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; Log.d(TAG, "=====onClick====="); switch (v.getId()) &#123; case R.id.btn_take_pic: takePhoto(); break; default: break; &#125; &#125; /*** * 调用相机拍照 */ private void takePhoto() &#123; Log.d(TAG, "=====takePhoto: ====="); /*+++++++针对6.0及其以上系统，读写外置存储权限的检测+++++++++*/ if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; // TODO: Consider calling // ActivityCompat#requestPermissions // here to request the missing permissions, and then overriding // public void onRequestPermissionsResult(int requestCode, String[] permissions, // int[] grantResults) // to handle the case where the user grants the permission. See the documentation // for ActivityCompat#requestPermissions for more details. return; &#125; if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; String sdPath = Environment.getExternalStorageDirectory() .getAbsolutePath(); mOutputFile = new File(sdPath, System.currentTimeMillis() + ".jpg");//拍照之后照片的路径 try &#123; if (!mOutputFile.exists()) &#123; mOutputFile.createNewFile(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Uri uri = Uri.fromFile(mOutputFile);//指定保存拍照后文件的Uri Log.i(TAG, "takePhoto: uri:===" + uri); Intent newIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照 newIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//将拍取的照片保存到指定Uri startActivityForResult(newIntent, REQUEST_CODE_TAKE_PHOTO); &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Log.d(TAG, "=====onActivityResult====="); if (requestCode == REQUEST_CODE_TAKE_PHOTO) &#123; onTakePhotoFinished(resultCode, data); &#125; else if (requestCode == REQUEST_CODE_CLIP_PHOTO) &#123; onClipPhotoFinished(resultCode, data); &#125; &#125; /** * 拍照完成 * * @param resultCode * @param data */ private void onTakePhotoFinished(int resultCode, Intent data) &#123; Log.d(TAG, "=====onTakePhotoFinished====="); if (resultCode == RESULT_CANCELED) &#123; Toast.makeText(this, "take photo canceled", Toast.LENGTH_SHORT) .show(); return; &#125; else if (resultCode != RESULT_OK) &#123; Toast.makeText(this, "take photo failed", Toast.LENGTH_SHORT) .show(); &#125; else &#123; /*调用裁剪图片的方法进行裁剪图片*/ clipPhoto(Uri.fromFile(mOutputFile)); &#125; &#125; /** * 裁剪照片 * * @param uri */ private void clipPhoto(Uri uri) &#123; Log.d(TAG, "clipPhoto====&gt;" + uri); Intent intent = new Intent("com.android.camera.action.CROP"); intent.setDataAndType(uri, "image/*"); // 下面这个crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra("crop", "true"); // aspectX aspectY 是宽高的比例 intent.putExtra("aspectX", 1); intent.putExtra("aspectY", 1); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, REQUEST_CODE_CLIP_PHOTO); &#125; /** * 裁剪照片完成 * * @param resultCode * @param data */ private void onClipPhotoFinished(int resultCode, Intent data) &#123; Log.d(TAG, "=====onClipPhotoFinished====="); if (resultCode == RESULT_CANCELED) &#123; Toast.makeText(this, "clip photo canceled", Toast.LENGTH_SHORT) .show(); return; &#125; else if (resultCode != RESULT_OK) &#123; Toast.makeText(this, "take photo failed", Toast.LENGTH_SHORT) .show(); &#125; Bitmap bm = BitmapFactory.decodeFile(mOutputFile.getAbsolutePath()); imgshow.setImageBitmap(bm); &#125;&#125; 以上示代码通过调用系统的照相机拍照，保存图片到sdcard，并裁剪显示到界面上。我们通过这个示例为代表，来说明本节的内容。 复现问题当然在Android 7.0以下，你依然可以使用上面的代码来实现拍照裁剪显示。但是当你使用的设备是Android 7.0及其以上的时候，使用以上代码，就会抛出开篇所提到的FileUriExposedException异常 android.os.FileUriExposedException:file://…. exposed beyond app through ClipData.Item.getUri() 解决方案定义FileProvider1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.xw.fileproviderdemo"&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.xw.fileproviderdemo.takePhoto.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 注： exported:必须为false,为true会报安全异常 grantUriPermissions:为true 表示授予该URI临时访问权限 验证可用的文件在res/xml资源目录下创建指定的xml文件 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="images" path="."/&gt;&lt;/paths&gt; 以上代码表示的是：可以访问外部存储目录更目录下的文件，因为拍照后的图片是保存在Environment.getExternalStorageDirectory()下的，也就是,故path的值这里用.号来代表当前的路径，name的值可以自定义。 注： 节点必须包含以下一个或者多个子节点: files-path 代表：Context.getFilesDir(). cache-path 代表：getCacheDir(). extenal-path 代表：Environment.getExternalStorageDirectory(). external-files-path 代表：Context#getExternalFilesDir(String) Context.getExternalFilesDir(null). external-cache-path 代表：Context.getExternalCacheDir(). 给Files生成Content URI1234567891011private void takePhoto() &#123; .... //Uri uri = Uri.fromFile(mOutputFile);//指定保存拍照后文件的Uri /*将file uri的获取方式由fromfile改变为由FileProvider.getUriForFile获取其中Authority应与AndroidManifest定义的保持一致*/ Uri uri= FileProvider.getUriForFile(this, "com.xw.fileproviderdemo.takePhoto.provider", mOutputFile); Log.i(TAG, "takePhoto: uri:===" + uri); Intent newIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//设置Action为拍照 newIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri);//将拍取的照片保存到指定Uri startActivityForResult(newIntent, REQUEST_CODE_TAKE_PHOTO); ....&#125; 以上的代码，将getUriForFile()返回的uri打印出来是:content://com.xw.fileproviderdemo.takePhoto.provider/image/xxxx.jpg 由此可以看出:image:就是xml中的子节点里定义的android:name的值com.xw.fileproviderdemo.takePhoto.provider/image对应的路径就是/storage/emulated/0那么com.xw.fileproviderdemo.takePhoto.provider/image/xxxx.jpg对应的路径就是/storage/emulated/0/xxxx.jpg 通过以上的代码修改，可以解决takePhoto()方法中拍照时的FileUriExposedException异常再次运行项目，可以进行拍照了，拍照完成后，接下来需要进行裁剪，BOOM……Crash…Stop !!!,项目又崩溃了，然后抛出以下的异常： 给URI临时授权同理，抛出的异常和上面takePhoto()一样,都是FileUriExposedException异常 将接收该uri的目的App的PackageName通过grantUriPermission（）函数进行设置,授予读写权限: 12345678910111213141516private void clipPhoto(Uri uri) &#123; Log.d(TAG, "clipPhoto====&gt;" + uri); this.grantUriPermission("com.android.camera", uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION); Intent intent = new Intent("com.android.camera.action.CROP"); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);//请求URI授权读取 intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);//请求URI授权写入 intent.setDataAndType(uri, "image/*"); // 下面这个crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra("crop", "true"); // aspectX aspectY 是宽高的比例 intent.putExtra("aspectX", 1); intent.putExtra("aspectY", 1); intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, REQUEST_CODE_CLIP_PHOTO);&#125; 同样，调用的时候也将file uri的获取方式由fromfile改变为由FileProvider.getUriForFile获取: 123/*调用裁剪图片的方法进行裁剪图片*/ //clipPhoto(Uri.fromFile(mOutputFile)); clipPhoto(FileProvider.getUriForFile(this, "com.xw.fileproviderdemo.takePhoto.provider", mOutputFile)); 最后，再次运行，所有Exception都解决了，Perfect ～ ! 效果如下： 以上就是简单的对Android 7.0上面权限改变之文件共享方面的概括总结，如有不足，欢迎指正，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[扩展Web技术和Android]]></title>
      <url>%2F2016%2F09%2F22%2FExtending-Web-Technology-with-Android%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Extending Web Technology with Android 纸飞机开始被作为一个简单的想法 —— “如果你能够扔一个纸飞机从一个屏幕到其他屏幕？” 我们概念的核心是将来自全世界的人团结在一起，使用强有力的web —— 一种即时连接到其他的。现代化web技术，特别是JavaScript和OpenGL,在每一个屏幕上使体验更有力量。 纸飞机最初的特色是在2016 Google I/O大会上，在Keynote上连接了参会者和户外的观众长达30分钟。在2016年国际和平日公开启动，我们创建了一个Android Experiment,在Google Play上也是一大特色，充实了现有的web技术和原生的Android Nougat功能，比如当一个飞机在世界的其他地方被抓获，丰富了通知。 介绍当用户添加一个邮编来预先填充它们的位置，创建并且折叠他们自己的飞机。一个简单的扔的手势启动飞机进入虚拟世界，用户访问桌面版网站将会看到它们的飞机进入屏幕飞行。 之后，用户能够检回，并看到他们自己的飞机已经抓住围绕着世界，在飞机上的每一个邮票读起来像一个密码，一个3D地球高亮飞行线路和已经旅行过的距离。 除了标记他们自己的飞机，用户能够手势操作他们的手机，像一个网去抓住一个从其他地方已经抛出的飞机，捏来并拧开它，表明这个地方它已经访问过了。然后他们能够添加他们自己的邮票，然后将它放回群中。 WebView在Google I/0的台上，我们开发的纸飞机运行时范围从50英尺的屏幕跨设备运行，桌面和移动端使用了Web的最新技术。 webGL从程式化的低多边形地球到植绒面,WebGL是采用了渲染3D元素，使之体验更有动力。我们写了自定义GLSL着色器来照亮地球，变形目标作为用户捏来打开或关闭纸时的动画。 Web套接字当用户“扔”一个飞机，一段信息是发送websockets到后端服务器，它被传递到所有的桌面电脑可视化的飞机起飞。 Web工作者飞机群模拟跨越，使用WebWorkers多线程计算每一架飞机的位置，并传达消息返回给主线程使用WebGL呈现出来 要创建的伟大工程，跨平台的体验，我们扩展了Web和原生Android代码，这个能够是我们利用Android中内置Chromium，去使应用程序的视图层与已经存在的网页代码进行深度整合，加入深度整合的操作系统，比如有丰富的通知和后台服务。 如果你对学习更多有关如何桥接WebView和Java代码有兴趣，看看这个GitHub库里的教程 通知Firebase 云端消息（FCM）使用发送推送通知到Android应用上，当一个用户的飞机已经其他人被抓住并扔出去了，一个通知会显示多少个城市和它航行的里程就会发送到这个飞机的FCM创建者设备上。传出通知去管理以确保它们不会过于频繁的发送到设备上。 后台服务我们实现一个后台服务去一天运行一次，对本地存储检查，以确保用户上次访问的应用程序运行。如果一个用户在两周以来都没有去访问过，该应用就会发送一条通知去邀请用户回到应用中去创建一架新的飞机。 网络通讯我们的应用运行在Google云平台的网络服务器上，对于邮票我们利用内置的地理编码头得到接近相似的位置，并套接字.IO流去连接到套接字全部服务器上的所有设备。 用户连接到他们附近的服务器，传达消息到一个单独的主服务器以及任何桌面版计算机观看该区域的经历体验。 往前看这种方法的工作对我们来说非常好，让光滑，跨平台和外形迷人的体验，连接来自全世界的人，扩展web和原生功能已被证明是一个有价值的途径，以提供高品质的体验前进。在Android Experiments网站上你能够学习更多相关的。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 2.2]]></title>
      <url>%2F2016%2F09%2F20%2FAndroid-Studio-2-2%2F</url>
      <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Android Studio 2.2 Android Studio 2.2 今天可以下载使用了。在2016年Google I/O 大会上已经被预览了，Android Studio 2.2是我们IDE最新版，全世界上百万的Android开发者在使用。 增强包装，这个版本有三个主要的主题：速度、智能、和Android 平台支持。利用比如新的Layout Editor（布局编辑器）创建一个应用用户界面更快、更直观，让开发更加快速。我们新的APK analyzer(分析器), 增强布局审查，扩展代码分析让开发更加智能。Intellij的2016.1.3特性以及更多。最后，作为Android应用开发的官方IDE，Android Studio 2.2包括支持在Android7.0中所有的最新版开发者特性，像代码完成去帮助你添加Android平台特性，像多窗口支持、快速设置API，或者重新设计Notification通知。当然，内置的Android Emulator 模拟器去测试所有推出的这些。 在这个版本中，我们改进了Android Frameworks 和 IDE 去创建一个约束布局，新的布局管理器更有力的去帮助你在一个平面上去设计大的和复杂的布局，同时也精简层次。ConstraintLayout像一个标准的Android support library（Android支持库）集成到你的应用中，在利用新的布局编辑器中平行去被构建。 Android Studio 2.2 包括了20+种特性贯穿了在开发过程中的每一个主要阶段：设计、开发、编译&amp;测试，从利用新的ConstraintLayout设计UIs,到利用Android NDK开发C++代码，到利用最新版的Jack编译器去编译，到创建一个Espresso去测试你app中的cases，Android Studio 2.2 升级你一定要去，不要错过了。这儿以下是上面说的一些更多详细的： 设计 布局编辑器 : 创建Android应用用户界面现在是很容易的了，使用全新的用户界面设计器。使用新的蓝图模式和调整每个插件能看到新的属性面板的属性，快速构建你的应用程序用户界面的结构。 约束布局 ：这个新的布局是一个灵活的布局管理器对于你的应用，允许你创建一个动态的用户界面没有嵌套多个布局，向后兼容到Android API Level 9(姜饼)。约束布局工作最好使用在Android 2.2上的全新的布局编辑器。学习更多 开发 提高对C++的支持 :你现在能够是利用CMake 或者 ndk-build从Gradle去编译你的C++项目。从CMake迁移项目编译系统到Android Studio现在是无缝的了。你将也能找到C++支持在全新的wizard项目在Android Studio中，加上了一大批对于C++编辑的bug修复和debug体验，学习更多 示例浏览器 : 使用Android Studio 2.2 引用Android Sample Code 示例代码现在是更容易了，在内置的代码编辑窗口，在Google Android 示例代码找到你应用代码的事件去帮助你跳跃开始你的app应用开发。 编译 即时运行的提高 : 在Android Studio 2.0中介绍了，Instant Run是我们主要的、长期投资的，去使Android开发快速，重量轻。自从推出，它对许多开发者已显著提高编辑、编译、运行、运行周期迭代。在这个版本中，我们已经做了很多的稳定性和可靠性改进Instant Run（即时运行），如果您先前已禁用即时运行，我们建议您重新启用它，让我们知道，如果你遇到进一步的问题。(在Windows/Linux上：Settings → Build, Execution, Deployment → Instant Run , 在OS X 上 ：Preferences → Build, Execution, Deployment → Instant Run). 有关我们所做的修复的详细信息，请参阅Andr​​oid Studio 2.2中发布说明。 APK 分析器 : 很简单的检查你的APK的内容，去了解每个组件的大小贡献。当你调试到mult-dex这个特性能对你有帮助，另外，利用APK分析器你能够比较一个APK的两个版本.学习更多 构建缓存(试验性) ：我们将继续我们的投资，以提高构建速度，推出了新的实验构建的缓存，这将有助于减少双方完全和增量构建时间。只需添加android.enableBuildCache =true 到你的gradle.properties文件中。学习更多 测试 Android 模拟器中的虚拟传感器：Android 模拟器现在包括了一个新的组是虚拟传感器控制，利用新的UI控制，你现在能够测试Android 传感器 比如加速度、温度、磁力仪等等更多。学习更多 Espresso 测试记录器(Beta) :该Espresso测试记录器以让你轻松通过记录与您的应用程序创建交互UI测试;它然后将会为你输出UI测试代码.你记录你和一个设备互动，然后，添加树到你应用特殊快照中的验证UI节点上，Espresso记录器然后就会保存记录，并进行自动化生成一个对应的UI测试。你能够在本地运行测试、在持续集成服务器上、或者是使用Firebase Test Lab for Android,学习更多 GPU 调试器(Beta) : 该GPU调试器现在还在Beta阶段，对于分析你现在能够在你的Android 设备上捕捉OpenGL ES指令流，然后从Android Studio里面回复它。你也能够完全审查给予任意OpenGL ES指令流的GPU的状态，去更好的理解和调试你的图形输出。学习更多 总的来说，Android Studio 2.2包括主要的特性和更多的： 设计： 布局编辑器 约束布局 布局审查器(试验性) 在Vector Asset Studio中支持PSD文件 开发 ： Firebase插件 升级代码分析&amp;Lint检查 加强无障碍支持 提高C++编辑支持&amp;调试 Itellij2016.1.3平台升级 示例浏览器 提高字体渲染 编译 ： Jack编译器改进 Java8语言支持 C++ ndk-build 或者CMake 合并Manifest视图器 编译缓存(试验性) OpenJdk支持 Instant Run即使运行改进 测试： Espresso 测试记录器 APK分析器 GPU调试器(试验性) 模拟器虚拟传感器 学习更多有关Android Studio 2.2通过重新查看发布说明和预览博客文章 开始获取下载如果你有上一个版本的Android Studio，你能够在菜单导航栏(Help → Check for Update (Windows/Linux系统) , Android Studio → Check for Updates (OS X系统))正式版渠道上检查更新,你也能够从官方下载页面进行下载，去获取Android Studio所有的新功能和改进,你应该也会升级Android Gradle 插件版本到2.2.0在你当前的app项目中。 以上是对Anroid 官网博客文章的部分翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 7.0 Nougat 最后的包装关闭]]></title>
      <url>%2F2016%2F08%2F23%2Ftaking-final-wrapper-off-of-nougat%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Taking the final wrapper off of Android 7.0 Nougat 今天，Android 7.0牛轧糖将会开始推出给用户，从Nexus设备开始。在同一时间，我们推送了Android 7.0源码到Android开源项目(AOSP),这个新版本的Android延长公开可用性到更广泛的生态系统。 在这个正式版上我们和你在过去的几个月中一起努力，获得你们的反馈，同时也确保你的应用程序已经准备好运行在这些用户的牛轧糖设备上 牛轧糖里面是什么Android 牛轧糖反映全世界成千上万粉丝和开发人员喜欢你的输入，在Android 牛轧糖中超过了250种基本功能特性，包括Android中的VR模式 ，在牛轧糖中，我们已经在Android栈的所有层面工作————从操作系统是如何读取传感器数据到如何发送像素到显示————到特别内置到提供高质量的移动VR体验 牛轧糖带你了一大批新特性，以帮助使Android功能更强大，更高效，更安全。它介绍了一个新的JIT/AOT编译器来提高软件性能，确保应用安装的更快，占用更少的存储空间。它也添加了对Vulkan平台的支持，一个低开销，高性能跨平台的API，3D图形。多窗口的支持让用户能够在同一时间运行两个应用。直接回复能让用户不用打开应用程序，直接在通知栏上回复。一如既往，Android的构建利用强大的安全层和加密去保护你的私有数据私有，因此牛轧糖引入了一些新的特性像基于文件的加密、无缝更新和直接启动 你能够在牛轧糖开发者资源这里找到所有，包括在行为改变和在你的应用中你能够使用的新特性的详细介绍。对于开发者有什么新的概述是可以使用在这里 ,你能够在这里探索牛轧糖里对于新用户的特性。 下一波用户从今天开始和接下来几周的推出，Nexus 6, Nexus 5X, Nexus 6P, Nexus 9, Nexus Player, Pixel C, and General Mobile 4G (Android One) 将会获得一个Android 7.0牛轧糖云端软件的升级。包括即将来到的LG V20 将会成为市面上第一个使用Android牛轧糖的新智能手机，开箱的。 所有的这些新设备开始运行牛轧糖，现在是发布你新的应用升级到Google Play的时候了，我们建议理想的编译目标API24。如果你是一直测试最后几分钟的变化，一个伟大的战略是使用Google Play’s beta testing feature从一个小组用户去获得尽早的反馈——包括使Android7.0牛轧糖——做一个分阶段发布，发布更新后的应用给所有用户。 对于牛轧糖接下来是什么？我们已经移动牛轧糖到一个新的定期维护计划，在未来几个季度。实际上，我们已经在第一个牛轧糖版本开始维护工作，这将带来持续的改进和润色，我们打算今年秋天把那个给你作为一个开发者预览版。敬请关注！ 我们将很快关闭对开发者开放的错误预览版记录，但是请保持反馈！如果你仍然看到有问题， 你在预览版跟踪器提交，只是文件新问题对Android 7的AOSP问题跟踪器。 感谢您成为预览的一部分,这是我们在今年早些时候分享了an eye towards giving everyone the opportunity，使下一个版本的Android更强大。您继续反馈是非常有益的在塑造这个最终版本，不是为了某一个用户，而是为了整个Android生态圈。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flutter开发之入门篇]]></title>
      <url>%2F2016%2F08%2F18%2FFlutter-get-started%2F</url>
      <content type="text"><![CDATA[上一节对于Flutter环境搭建的学习，本节向导将会快速的描述在ios或者Android上创建和运行你的第一个Flutter应用 开始之前对于写一个Flutter应用，你将需要安装好Flutter SDK。同时你也需要设置一个Linux或者Mac开发机器去在Android 或者ios上运行和测试你的应用。见Flutter搭建篇将会描述如何搭建你的开发环境的 创建你的第一个Flutter应用对于创建一个开始的项目，打开terminal终端，然后运行flutter命令这儿是一个示例1$ flutter create myapp 以上的命令创建一个Flutter项目目录，被叫做myapp，它包含了一个简单的示例，使用了Material Design在这个项目的目录中，对于你的app代码是在myapp/lib/main.dart 运行你的Flutter应用使用flutter run命令运行你的Flutter应用到你已经连接成功的所有设备或者模拟器(flutter devices命令将会列出你已经连接成功的设备或者模拟器) 对于从命令行运行你的应用：1、打开一个teminal终端,并改变它的目录到你的app根目录下(对于你的项目，这个相同的目录下包含了一个pubspec.yaml文件)2、运行如下命令:1$ flutter run 另外，如果你是使用的Atom editor和Flutter package,你能够通过选择在项目lib/main.dart中的文件，然后在主界面上点击运行app的快捷键开始你的Flutter应用。快捷键依赖于你使用的开发机器的操作系统: Linux Ctrl+R Mac Command+R 如果程序能正常工作，你应该能看到你的应用已经在你的设备或者模拟器上面启动起来了 iOS (iPhone 6s Plus) Android (Nexus 6) 以上操作就完成了Flutter的入门操作 以上部分具体内容来源Flutter官网，对其译文并扩展，如有不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flutter开发之搭建篇]]></title>
      <url>%2F2016%2F08%2F17%2FFlutter-setup%2F</url>
      <content type="text"><![CDATA[Google的Git源码库出现了一种新的开源操作系统叫Fuchsia,该系统的UI用户界面层使用的是Dart语言开发的Flutter，渲染器是Escher，应用程序框架是Mojo。那么我们先来了解一下这个Flutter Flutter，是一个帮助开发者从一个单一的代码库，去构建ios和Android上高性能、高保真的移动设备应用新项目。 本节向导将描述如何搭建你的开发环境，在ios或者Android上运行Flutter应用 系统要求要安装和运行Flutter，你的开发环境必须满足这些最低要求： 操作系统：Mac或者Linux(64位).Windows已加入支持计划 工具：Flutter在你的环境中依靠这些命令行工具才可以使用.bash,mkdir,rm,git,curl,unzip 获取 Flutter SDK对于获取Flutter,使用git去clone仓库，然后添加flutter工具到你的path：12$ git clone https://github.com/flutter/flutter.git -b alpha$ export PATH=`pwd`/flutter/bin:$PATH 运行以下命令来看看是否有您需要安装完成设置任何依赖关系：1$ flutter doctor 在第一次运行flutter命令的时候,它将会下载它的依赖并且自己编译，后续运行的时候应该会快 一旦你已经安装任何缺少的依赖，再一次运行flutter doctor命令，来验证是否已正确设置一切。 Google Analytics（分析）Flutter 工具使用了Google Analytics进行使用情况的数据统计报告功能和基本崩溃报。随着时间的推移，这些数据能够帮助提高Flutter工具。为了禁用报告，在终端输入flutter config --no-analytics，对于要显示出当前analytics分析报告的状态，在终端输入flutter config Analytics是不会在最初的运行或任何涉及flutter config运行去发送。这让用户选择退出分析，而不发送任何数据。见Google的隐私政策https://www.google.com/intl/en/policies/privacy/ ios环境设置这步是可选的，对于在ios中使用Flutter开发之前，在任何时间都是可以被执行的对于在ios上开发Flutter应用，你需要一个带有Xcode7.2或者更高版本的Mac设备： 1.安装Xcode7.2或者更高版本(来源网页下载或者Mac App Store) 2.确保Xcode EULA是通过通过任一开放一次的Xcode签名了并且确认了，或者从命令行运行sudo xcodebuild -license 利用Xcode，你将能够在一个IOS设备上或者在一个模拟器上运行Flutter应用 建立ios模拟器对于准备在ios模拟器运行和测试你的Flutter，如下步骤：1、在你的Mac，找到来源于Spotlight的模拟器，或者通过使用以下命令： $ open -a Simulator2、确保你的模拟器是使用的一个64位的设备（iphone5s或者之后的版本），通过在模拟器的Hardware&gt;Device菜单中检查设置。 3、依赖于的你的机器屏幕大小进行开发，根据开发该机的屏幕尺寸，模拟高密度的ios设备可能会溢出屏幕，在模拟器中设置设备的缩放，在Window下&gt;Scale菜单中。 部署到ios设备对于部署你的Flutter应用到一个物理的ios设备，你将需要一些额外的工具： 1、安装homebrew 2、打开终端。对于在ios设备上部署Flutter应用，运行这些命令去安装工具。12$ brew tap flutter/flutter$ brew install ideviceinstaller ios-deploy 您还需要建立一个供应配置文件为您的开发者账户。要了解如何设置您的个人资料,请查阅 Apple’s official documentation Android环境设置这步是可选的，对于在Android中使用Flutter开发之前，在任何时间都是可以被执行的对于在Android上开发Flutter应用，你能够使用一个Mac或者一个linux(64位)的机器： 1、安装Android Studio2、Android Studio，安装最新版的Android SDK和Android SDK Platform-Tools，如Adding SDK Packages所述 设置你的Android设备对于准备在Android上运行和测试你的Flutter应用，你将需要一个运行在Android4.1(API level 16)或者更高的Andoid设备1、开启开发者模式在你的设备，通过访问设置 &gt; 关于手机，点击版本号行7次2、在 设置 &gt; 开发者选项，开启USB3、使用USB数据线将手机和电脑连接在一起，如果在你的设备上提示了，授权你的电脑访问你的设备4、在终端运行flutter devices命令验证Flutter识别到你已经连接的Android设备 默认情况下，Flutter使用的adb工具和Android SDK版本是依赖的。如果你先Flutter使用一个不同版本安装的Android SDK,你必须设置ANDROID_HOME到你的环境变量是具体的安装目录。 Atom 编辑器我们建议使用Atom进行编辑，运行，和调试Flutter应用。然后，使用我们命令行工具，你能够使用任你可以用任何编辑器来开发Flutter应用对于安装Atom：1、从atom.io站点下载Atom2、从下载文件进行解压，并执行Atom 配置Atom开发环境在你在A创建你的Flutter项目之前，你将需要执行这些起飞前的任务：1、启动Atom编辑器2、通过以下这些步骤安装Flutter package: 从菜单栏，打开Packages &gt; Settings View &gt; Install Packages/Themes 在Install Packages区域，输入flutter并且点击Packages按钮 你应该能看到Flutter包已经显示出来了，点击按钮进行安装这个包 3、打开Packages &gt; Flutter &gt; Packages Settings，设置FLUTTER_ROOT区域为你安装Flutter SDK的根目录的路径 4、打开Packages &gt; Dart &gt; Packages Settings，设置Dart SDK Location 区域为你Flutter SDK的根文件夹bin/cache/dart-sdk目录的路径 5、如果你在Mac上使用Atom，你应该安装atom和apmshell命令。从菜单栏这样操作，点击Atom&gt;Install Shell Commands 以上操作就完成了Flutter的环境搭建操作，下一篇来学习Flutter入门 以上部分具体内容来源Flutter官网，对其译文并扩展，如有不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Material Design组件之Bottom sheets]]></title>
      <url>%2F2016%2F08%2F02%2FMaterial-Design-Bottom-sheets%2F</url>
      <content type="text"><![CDATA[Google Material Design之Bottom Sheet文档 本节介绍Material Design中的组件之一Bottom Sheet 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat和design依赖库.1234dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本 compile 'com.android.support.design:X.X.X'//这里的X.X.X代表版本&#125; 2、设置app:layout_behavior属性的值@string/bottom_sheet_behavior,将允许你的View或者ViewGroup作为一个bottom Sheet展现出来12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="300dp" android:orientation="vertical" android:padding="16dp" app:layout_behavior="@string/bottom_sheet_behavior"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Dandelion Chocolate" android:textAppearance="@style/TextAppearance.AppCompat.Display1" android:textColor="@android:color/black"/&gt;&lt;/LinearLayout&gt; 提示：你能够使用behavior_peekHeight属性设置bottom sheet的默认高度3、添加你的视图作为直接为CoordinatorLayout的一个孩子，实现bottom sheet的特性1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbarLayout" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" &gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/appbar" android:layout_height="?attr/actionBarSize" android:layout_width="match_parent" android:minHeight="?attr/actionBarSize" android:background="?attr/colorPrimary" app:elevation="4dp" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" &gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- Your content --&gt; &lt;include layout="@layout/content_main" /&gt; &lt;!-- Bottom Sheet --&gt; &lt;include layout="@layout/bottom_sheets_main" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 提示：你能够在&lt;include&gt;节点下包裹你的View或者ViewGroups,为了保持整理你的布局。请记住，bottom sheet中的滑动容器（scrolling container）必须支持嵌套滑动（比如 NestedScrollView, RecyclerView, 或者API 21以下的ListView/ScrollView）。 4、根据一个视图有着底部特性设置的引用来获得一个BottomSheetBehavior的引用，使用BottomSheetBehavior里的from方法1234567891011121314151617LinearLayout bottomSheetViewgroup = (LinearLayout) findViewById(R.id.bottom_sheet);BottomSheetBehavior bottomSheetBehavior = BottomSheetBehavior.from(bottomSheetViewgroup);//如果你想接收状态改变的回调，可以加一个BottomSheetCallbackbottomSheetBehavior.setBottomSheetCallback(new BottomSheetCallback() &#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &#123; // React to state change &#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &#123; // React to dragging events &#125; &#125;); 5、对于展开你的bottom sheet使用setState方法并传递参数BottomSheetBehavior.STATE_EXPANDED1bottomSheetBehavior.setState(BottomSheetBehavior.STATE_EXPANDED); 提示：你能够处理来源于setState方法的这些状态： STATE_COLLAPSED： 默认的折叠状态， bottom sheets只在底部显示一部分布局。显示高度可以通过 app:behavior_peekHeight 设置（默认是0） STATE_DRAGGING ： 过渡状态，此时用户正在向上或者向下拖动bottom sheet STATE_SETTLING: 视图从脱离手指自由滑动到最终停下的这一小段时间 STATE_EXPANDED： bottom sheet 处于完全展开的状态：当bottom sheet的高度低于CoordinatorLayout容器时，整个bottom sheet都可见；或者CoordinatorLayout容器已经被bottom sheet填满。 STATE_HIDDEN ： 默认无此状态（可通过app:behavior_hideable 启用此状态），启用后用户将能通过向下滑动完全隐藏 bottom sheet Modal bottom sheets BottomSheetDialog创建一个BottomSheetDialog,例如：123456789BottomSheetDialog dialog = new BottomSheetDialog(context);View view = LayoutInflater.from(context).inflate(R.layout.bottom_sheet_list, null);RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.bottom_sheet_recycler_view);recyclerView.setLayoutManager(new LinearLayoutManager(context));recyclerView.setAdapter(new SimpleAdapter());dialog.setContentView(view);dialog.show(); BottomSheetDialogFragment1、创建一个类继承BottomSheetDialogFragmentinflated一个布局，将会作为你的Modal bottom Sheet的内容而被使用1234567891011121314151617public class ModalBottomSheet extends BottomSheetDialogFragment &#123; static BottomSheetDialogFragment newInstance() &#123; return new BottomSheetDialogFragment(); &#125; @Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate( R.layout.bottom_sheet_modal, container, false); return v; &#125;&#125; 2、创建一个你的modal bottom sheet实例并且使用它的show方法去显示，需要传递的参数是一个SupportFragmentManager和一个String.12ModalBottomSheet modalBottomSheet = new ModalBottomSheet();modalBottomSheet.show(getSupportFragmentManager(), "bottom sheet");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Material Design组件之Buttons]]></title>
      <url>%2F2016%2F08%2F01%2FMaterial-Design-Components-Buttons%2F</url>
      <content type="text"><![CDATA[Google Material Design之Buttons文档 本节介绍Material Design中的组件之一Buttons,包含3中Button的简单添加和使用，它们分别是Floating Action Button、Raised Button以及Flat Button Floating Action Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat和design依赖库.1234dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本 compile 'com.android.support.design:X.X.X'//这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity.123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的FloatActionButton.1234&lt;android.support.design.widget.FloatActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_fab"&gt; 如何设置Style? 背景颜色1、在你的values/style.xml中自定义style.123&lt;style name="MyFloatActionButton" parents="Theme.Appcompat.Light"&gt; &lt;item name="colorAccent"&gt;@drawable/pink&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到FloatActionButton12345&lt;android.support.design.widget.FloatActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_fab" android:theme="@style/MyFloatActionButton"&gt; 水波纹颜色当你按压FloatActionButton使用app:rippleColor去改变颜色达到水波纹的效果1234&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" app:rippleColor="@color/ripple"&gt; 图标对于改变FloatActionButton的图标使用android:src属性1234&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_myicon"&gt; 大小对于改变FloatActionButton图标的大小使用app:fabSize属性，使用一个预先系统设置的常量mini或者normal12345&lt;android.support.design.widget.FloatActionButton android:layout_widget="wrap_content" android:layout_height="wrap_content" android:src="@drawable/ic_mini" app:fabSize="mini"&gt; Raised Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat依赖库.123dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity.123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的Button.1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button"/&gt; 如何设置Style?1、在你的values/style.xml中自定义style.1234&lt;style name="MyButton" parent="Theme.AppCompat.Light"&gt; &lt;item name="colorControlHighlight"&gt;@color/indigo&lt;/item&gt; &lt;item name="colorButtonNormal"&gt;@color/pink&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到Button12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:theme="@style/MyButton"/&gt; 兼容性问题1、你能够使用colorControlHighlight这个属性去改变Button在按压时候的颜色，然后它将只有Android版本至少是Lolipop才会生效。2、Androidelevation属性只有在Lolipop的设备才会可以用，在Lolipop之前的设备你将看不到Button四周的shadow(阴影) Flat Button 如何添加？1、在你的builde.gradle文件中，添加最新版的appcompat依赖库.123dependencies &#123; compile 'com.android.support:appcompat-v7:X.X.X' //这里的X.X.X代表版本&#125; 2、确保你的Activity继承了android.support.v7.app.AppCompatActivity.123public class MainActivity extends AppCompatActivity&#123; ...&#125; 3、在layout.xml文件里的任意位置定义你的Button,并使用Borderless的style.12345&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" style="@style/Widget.AppCompat.Button.Borderless"/&gt; 如何设置Style? 1、在你的values/style.xml中自定义style.123&lt;style name="MyButton" parent="Theme.AppCompat.Light"&gt; &lt;item name="colorControlHighlight"&gt;@color/indigo&lt;/item&gt;&lt;/style&gt; 2、使用android:theme应用这个style到Button123456&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:theme="@style/MyButton" style="@style/Widget.AppCompat.Button.Borderless"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中使用兼容库创建Vector Drawable]]></title>
      <url>%2F2016%2F07%2F31%2Fandroid-vector-drawable-example-using-appcompat-support-library%2F</url>
      <content type="text"><![CDATA[随着Android应用程序兼容性支持库v23.2的新版本到来，它的一些特性也向后兼容并且增加了一些新功能。随着Android Lolipop（API 21）的发布，一个新的组件被包括进来，它被叫做矢量绘制对象。但是这个组件仅仅能在API21+上使用，现在的Androidy应用程序兼容性支持库v23.2矢量绘制对象的到来，可以为可绘制性提供强大的向后兼容性，可兼容API7+设备。 什么是 Vector Drawable ？正如它的名字所暗示的那样，Vector Drawable基于矢量图像。相对于光栅图形，矢量图形是描述使用几何形状图形元素的一种方式，它类似于SVG文件。在Vector Drawable中它是利用XML文件被创建出来。在Vector Drawable添加到Android SDK之前，开发者对于不同的显示分辨率必须创建多个版本的图像，这需要花费时间创建额外的asstes，并且消耗更多的空间，以致于增大apk文件的大小。如今这里不需要为mdpi,hdpi,xhdpi等等设计不同大小的图像，利用Vector Drawable你只需要创建图像仅仅一次作为一个XML文件，你将能够对于所有显示分辨率和不同的设备进行缩放。 如何使用Vector Drawable ？升级builde.gradle 文件在你项目中能够使用Vector Drawable之前，你需要添加兼容行代码到你的build.gradle文件下Gradle depencies模块中(以下版本必须满足v23.2+)然后重新编译一下项目 1234dependencies &#123; ... compile 'com.android.support:appcompat-v7:23.2.1'&#125; 如果你是使用的Gradle plugin插件版本在2.0或者及其以上，请添加以下代码： 123456// Gradle Plugin 2.0+ android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125; &#125; 如果你是使用的Gradle plugin插件版本在1.5或者及其以下，请添加以下代码： 12345678910// Gradle Plugin 1.5 android &#123; defaultConfig &#123; generatedDensities = [] &#125; // This is handled for you by the 2.0+ Gradle Plugin aaptOptions &#123; additionalParameters "--no-version-vectors" &#125; 我当前的Android Studio是 2.2 priview 6: 创建Vector Drawable创建Vector Assets目录在你的Android Studio中选中drawable文件夹&gt;右键点击&gt;new&gt;Vector Assets Vector Asset Studio Tool现在Vector Asset Studio 工具窗口会出现 创建Vector drawable xml创建Vector drawable xml 文件有两种方式:默认的Material 图标、加载本地SVG文件 Material 图标选择Material图标选项，然后点击icon,它将会出现一个选择icon的窗口，在这里你可以选择任意一个你期望的图标。我这里选择了一个定位的图标，点击OK 这个窗口显示了刚刚选择的图标进行预览，我默认设置它的size为24x24dp,现在点击下一步 这个窗口运行你设置目标Module和Res目录(可以选择debug或者release其中一种)，配置完成后点击Finish完成 以下就是上面过程的结果，将会在drawable文件夹中生成Vector drawable ic_location_on_black_24dp.xml 加载本地SVG文件选择Local SVG File，然后点击下面的path，弹出一个新的窗口，选择本地svg 文件。 这个窗口显示了刚刚导入的SVG图标进行预览，我默认设置它的size为24x24dp,现在点击下一步 这个窗口运行你设置目标Module和Res目录(可以选择debug或者release其中一种)，配置完成后点击Finish完成 以下就是上面过程的结果，将会在drawable文件夹中生成Vector drawable ic_dollar.xml 修改strings.xml添加以下string values到res =&gt; values =&gt; strings.xml 12345&lt;resources&gt; &lt;string name="material_icon"&gt;Material Icon&lt;/string&gt; &lt;string name="svg_file_icon"&gt;Local SVG File Icon&lt;/string&gt; &lt;string name="dynamic_icon"&gt;Vector Image Dynamic Icon&lt;/string&gt;&lt;/resources&gt; 修改layout.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.shoewann.myapplication.MainActivity"&gt; &lt;TextView android:id="@+id/tv_material_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/material_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toTopOf="@+id/activity_main" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/ic_location" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:contentDescription="" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/tv_material_icon" app:layout_constraintRight_toRightOf="@+id/tv_material_icon" app:layout_constraintTop_toBottomOf="@+id/tv_material_icon" app:srcCompat="@drawable/ic_location_on_black_24dp" tools:ignore="ContentDescription" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:id="@+id/tv_svg_file_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/svg_file_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toBottomOf="@+id/ic_location" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/ic_dollar" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:contentDescription="" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/ic_location" app:layout_constraintRight_toRightOf="@+id/ic_location" app:layout_constraintTop_toBottomOf="@+id/tv_svg_file_icon" app:srcCompat="@drawable/ic_dollar" tools:ignore="ContentDescription" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:id="@+id/tv_dynamic_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" android:text="@string/dynamic_icon" android:textColor="@android:color/black" android:textSize="25sp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toBottomOf="@+id/ic_dollar" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" /&gt; &lt;ImageView android:id="@+id/dynamic_icon" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center_vertical" app:layout_constraintLeft_toLeftOf="@+id/tv_dynamic_icon" app:layout_constraintRight_toRightOf="@+id/tv_dynamic_icon" app:layout_constraintTop_toBottomOf="@+id/tv_dynamic_icon" tools:layout_constraintLeft_creator="1" tools:layout_constraintRight_creator="1" tools:layout_constraintTop_creator="1" tools:ignore="ContentDescription" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 修改 MainActivity.java 123456789101112131415161718package com.example.shoewann.myapplication;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.ImageView;public class MainActivity extends AppCompatActivity &#123; private android.widget.ImageView dynamicicon; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.dynamicicon = (ImageView) findViewById(R.id.dynamic_icon); this.dynamicicon.setImageResource(R.drawable.ic_dollar); &#125;&#125; 运行效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化之Traceview]]></title>
      <url>%2F2016%2F07%2F30%2FAndroid-Performance-Part-Of-Traceview%2F</url>
      <content type="text"><![CDATA[上次学习总结了《Android性能优化之渲染篇》，间隔两个月了，今天抽空先简要的学习总结下第二篇部分内容，好了，废话不多说了。 为了优化你的代码，你需要理解系统如何运行代码。 缓慢的性能缓慢的函数执行通常是由于两方面的问题造成的：1、执行速度很慢的函数，这种函数很容易被发现，你的某些函数所花费的时间超过你的预期2倍、10倍数，甚至50倍。这种情况只要找到那些运行很慢的函数,查看代码，找到问题的所在，然后想办法解决就可以了。 2、更难发现的是第二种类型，想方设法都难以发现，每个函数所用的时间都额外增加了一毫秒，从而导致整个程序执行速度变慢数百毫秒。而且更难以解决，需要对每段细小的地方进行分析，这样可能会导致进度缓慢，影响效率。不过SDK有一些很不错的工具，帮助你找到这些有问题的代码部分。 Traceview 演练工具:Traceview 首先连接设备，然后启动想要分析的应用程序，然后回到Android Studio,启动Android Device Monitor(菜单栏Tools&gt;Android&gt;Android Device Monitor) 在左边的Devices窗格下，找到已经连接好的设备。 选择需要分析的应用活动。然后会在顶部有一些图标会亮，尤其是看上去像是三面的箭头，上面有一个红色的圆点。点击这个会提示开始进行方法分析，这就是Traceview的启动方法。 我们点击它会出现一个弹出窗口，提示会有两种方法来分析你的应用程序，你可以记录每个方法的输入和输出，它们对资源的要求很高，或者，你也利用示例代码进行一些分析。默认情况下分析程序将会没毫秒侦测一次你的应用程序，以发现和记录实际上在运行的功能，我们默认继续开始侦测，然后回到应用进行交互。 我们在对应用进行交互好了之后，同样再次点击刚刚带红点的三面箭头图标，只不过它现在不是红色的点，而是黑色的图标或者黑色的小方块，点击它停止Traceview侦测，然后再右边你将会看到跟踪记录的视图。 跟踪视图有两个主要的组成部分： 上方的窗体名称是typeline面板， 下方内有很多的信息，成为profile面板，这个时间线能够很好的现实代码的执行情况。 上边的每一行实际对应你一个线程，显示的每一个颜色，对应一个正在运行的特定方法。可以查看一个线程的开始时间和结束时间，还可以支持放大的功能，找到特定的方法，了解它们是如何执行的，条形的宽度表示方法执行所用的时间。我我们选择一个方法，跳转到跟踪视图窗口的底部: 这里，我们看到下方profile面板一些分析数据显示出来了，我们可以看到哪些方法调用了我们选定的方法，可以通过这些信息找到哪些地方耗时了。另外一个十分有用的信息是，方法被调用了多少次，或者递归调用本身多少次，我们可以看到下方的profile面板有一列名为“calls and recursion”，此列显示方法被调用了多少次，最底部有个搜索栏，可以搜索需要的东西。 以上就是个人对《Android 性能优化》的主要内容进行的总结,如有不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用更多的Linux内核防御保护Android]]></title>
      <url>%2F2016%2F07%2F28%2Fprotecting-android-with-more-linux%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Protecting Android with more Linux kernel defenses Android主要依赖于Linux内核的安全​​模式执行。为了更好的保护好内核，我们在Android内启用了一系列的机制，在较高的等级下这些保护在一个组中被划分为两类——内存保护和减少攻击面。 内存保护通过内核提供的主要安全功能之一，是对于用户空间进程在地址空间分离的形式进行内存保护。不像用户空间进程，内核的各种任务生活在一个地址空间，并且一个漏洞无论在内核的任意位置，可以潜在的影响到系统存储器的无关部分。内核内存保护是保持内核的完整性，不管漏洞而被设计。 标记内存为只读/不执行这个功能细分内核内存到逻辑部分，并设置在每一个部分的限制页面访问权限。代码标记为只读+执行。数据片段被标记为不执行，并且进一步分段成只读和读写片段。这个功能特性利用配置选项CONFIG_DEBUG_RODATA进行启用。它是通过Kees Cook一起输入，是基于由Brad Spengler的Grsecurity的KENRNEXE功能的一个子集和Larry Bassel和Laura Abbott的高通的CONFIG_STRICT_MEMORY_RWX feature功能。CONFIG_DEBUG_RODATA在内核上游登陆对于arm/arm64,并且已经回迁到Android的3.18+arm/arm64常见的内核。 RESTRICT内核访问到用户空间这个功能通过防止它直接访问用户空间内存来提高内核的保护。它能够使一系列的攻击变得更加困难，因为攻击者在内核内存有显著较少的控制可以去执行，尤其是利用CONFIG_DEBUG_RODATA启用。类似的功能已经存在，最早存在的是Grsecurity的UDEREF。这个功能可以利用配置选项CONFIG_CPU_SW_DOMAIN_PAN被启用，并且对于ARMv7是通过Russell King被实施，回迁到Android的4.1内核通过Kees Cook. 加强保护防止堆栈缓冲区溢出就像它的前身,堆栈保护器.加强堆栈保护防止堆栈缓冲区溢出。但另外提供覆盖对于更多数组类型,因为原来只有保护的字符数组,加强堆栈保护是由Han Shan被实施，并加入到GCC编译器4.9。 减少攻击面减少攻击面，试图揭露较少的入口点到内核，而不会打破合法的功能。减少攻击面能够包括移除代码，移除访问入口点，或者选择性地曝光功能。 移除默认的调试访问功能内核的perf系统对于性能测试提供基础设施，可用于分析内核和用户空间的应用程序。Perf是一个为开发人员提供了有价值的工具，但是对于绝大多数的Andr​​oid用户添加了不必要的攻击面。在Android牛轧糖，访问perf将会默认被阻止。开发者仍可以通过启用开发者选项和使用adb设置一个配置:”adb shell setprop security.perf_harden 0”进行启用访问。 为阻止访问perf的补丁集可被分解成内核和用户空间部分。内核补丁是通过Ben Hutchings并且是从Grsecurity的CONFIG_GRKERNSEC_PERF_HARDEN通过Brad Spengler被派生。用户控件是由Daniel Micay作出了贡献。感谢Wish Wu和其他对于在perf里负责任披露安全漏洞的其他人。 限制应用程序访问ioctl命令很多Android安全模型是由SELinux进行描述和强制执行的。ioctl()系统调用代表了一大空白在强制粒度来源于SELinux。ioctl命令白名单和SELinux被添加作为一种手段来通过SELinux提供在ioctl系统命令控制. 在Android上，大多数内核漏洞报告发生在驱动程序和ioctl系统调用使用均达到。例如CVE-2016-0820.一些ioctl命令是需要通过第三方应用，但大多数都没有和访问能够不破坏合法的功能会受到限制。在Android牛轧糖，仅仅一小白名单套接字ioctl命令对于应用是可用的。对于选择的设备，应用的访问到GPU(图形处理器)的ioctl访问已经被受到类似的限制。 需要SECCOMP-BPFSeccomp提供了一个额外的沙箱机制，允许一个进程使用可配在的过滤器来限制可用的系统调用和系统调用参数。限制系统调用的可用性可以显著的降低内核的攻击暴露的表面。自从Seccomp首次在棒棒糖的Nexus设备上被介绍，其整个Android生态系统的可用性稳步提高。Android牛轧糖，seccomp支持所有设备的请求。在Android牛轧糖上，我们正在使用seccomp在mediaextractor和mediacodec过程作为媒体硬化努力的一部分。 不断努力这儿有其他一些针对于保护内核正在进行的项目： 内核自身的保护项目是开发运行时和编译防御的上游内核。 正在AOSP中进行对SELinux进一步的沙箱收紧和减少攻击面的操作。 Minijail提供了一个方便的机制，将内核提供的众多遏制和沙箱功能，包括过滤器的seccomp和命名空间。 像kasan和kcov帮助模糊器发现崩溃的根本原因，并智能地构建测试用例增加代码覆盖率，最终导致更有效的缺陷跟踪过程。 由于这些努力和其他人，我们预计内核的安全​​性继续改善。在我们的工作上我们赞赏反馈，对于我们如何提高Android欢迎提出建议，在security@android.com和我们联系。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[连接你的应用程序到一个Wi-Fi设备]]></title>
      <url>%2F2016%2F07%2F21%2Fconnecting-your-app-to-wifi-device%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Connecting your App to a Wi-Fi Device 随着物联网的逐步成长，Android应用能够连接到Wi-Fi设备也越来越普遍。无论你是在创建一个远程取景器的应用，去设置连接到灯泡,或者是去控制一个四轴飞行器。如果它是依靠Wi-Fi你将需要连接到一个热点，或许这个热点不需要有internet网络连接访问。 从棒棒糖版本开始往前的系统变得更加智能了，允许多重网络连接且不会讲数据路由到一个不具有internet连接的网络。那样对用户来说非常有用，因为当他们附近的WIFI接近阳台的时候不会丢失连接。为开发者已经添加了数据路由接口文档（Data routing APIs），因此，你能够确保只有适当的应用程序的流量路由通过Wi-Fi连接到已经存在的设备上。 对于使用这个接口文档，理解起来也是非常简单的。这儿有3中网络设置对于开发者可以使用，知道这些就好了： WiFiManager#开始扫描(startScan)返回一个可用Wi-Fi网络列表清单，它们是通过是私有的SSID来确定的。 WiFiManager#获取网络配置(getConfiguredNetworks)在设备上返回一个Wi-Fi网络配置列表清单，同时通过SSID来作为索引，但是它们不一定当前可以使用。 ConnectivityManager#获取所有的网络(getAllNetworks)返回一个通过手机正在互动的网络列表，从棒棒糖版本开始往前这是必要的，一个设备一次或去连接到了多重网络，Wi-FI、LTE、Bluetooth等等，通过调用ConnectivityManager#getNetworkInfo)和一个网络ID是可以确认每个的当前状态是可用的。 你可以在所有的Android版本中通过使用WiFiManager#startScan)去扫描可用的Wi-Fi网络，遍历ScanResults去查找你外部Wi-Fi设备的SSID。一旦你发现了它，你能够检查，如果它已经利用WiFiManager#getConfiguredNetworks)配置了一个网络，并通过WifiConfigrations遍历返回，和SSID进行匹配。那些SSIDs配置的网络是用双引号括起来的就需要值得去注意了，而所述的SSID在ScanResults中返回的不是。 如果你的网络配置了，你能够从WifiConfiguration对象里面去获取这个网络的ID，除此之外，你能够使用WifiManager#addNetwork)配置它，保持网络id追踪，那样可以返回。 对于连接到Wi-Fi网络，注册一个对于WifiManager.NETWORK_STATE_CHANGED_ACTION的BroadcastReceiver的监听,并且然后调用WifiManager.enableNetwork(int netId,boolean disableOthers)),通过在你的网络ID。对于下一次的扫描，该enableNetwork禁用了所有其他访问点，定位到你所请求的那一个，然后连接它。当你收到了网络广播的时候，你可以使用WifiManager#getConnectionInfo)检查,你将成功的连接到正确的网络。但是，在棒棒糖及其以上，如果那个网络没有internet网络连接，请求将不会被路由到它上面。 路由网络请求 从你的应用程序到一个已存在的Wi-Fi设备，面对所有网络的请求，在棒棒糖设备上调用ConnectivityManager#setProcessDefaultNetwork)，在棉花糖设备上调用ConnectivityManager#bindProcessToNetwork)代替，这是一个直接的API替代。注意这里调用需要请求android.permission.INTERNET，否则它们将会返回false。 另外，如果你喜欢你的应用程序传输到Wi-Fi设备和一些Internet网络通过移动数据路由： 对于Http请求你能够使用Network#openConnection(java.net.URL)),直接路由你的请求到这个网络。 对于低等级的Socket套接字交互，打开一个socket套接字，然后调用Network#bindSoket(java.net.Socket)),或者另外使用Network#getSocketFactory)。 现在你能够保持你的用户连接，让他们从创新的Wi-Fi功能产品中受益。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Google意识API创建智能，环境感知应用程序]]></title>
      <url>%2F2016%2F06%2F28%2Fcreate-intelligent-context-aware-apps%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Create Intelligent, Context-Aware Apps with the Google Awareness APIs 在上个月的2016 Google I/O大会上宣布的全新的Google意识API。启用你的应用程序感知用户上下文响应，使用快照和围栏对系统资源的影响微乎其微。 今天我们骄傲的宣布通过Google Play服务对于所有的开发者都能够使用Google意识API。 利用7种不同类型的上下文——包括位置、天气、用户活动和附近的信标——你的应用程序能够更好的理解你这个用户当前的状况，并且使用这些信息提供优化和定制经验。 意识API提供两种方式在你的应用程序中提供信标： 快照API，让你的应用程序能够简易的请求有关用户当前的上下文信息，比如，“给我用户当前的位置和当前的天气情况”。 围栏API，让你的应用程序能够响应用户的上下文变化，—— 当它匹配到了一组特定的条件，比如，“当用户在步行和耳机是插入状态时告诉我”，类似于地理围栏API，一旦意识围栏被注册，它可以发送回调信息给你的应用程序，即使它没有运行。 在全新的方式里,作为一个单一的，简面化，意识API结合优化处理上下文信标。以前是不可能的，提供更准确和深刻的上下文线索，同时还管理着系统资源，以节省电池和减少带宽。 我们将会于我们的一些合作伙伴密切合作，我们已经发现了惊人的方式集成到他们的应用程序中去感知上下文： Trulia,一个网上住宅房地产网站，利用我们围栏API去建议打开房间。当天气是非常棒的时候，用户能够在它们的房子周围散步，它们会觉得很有意思。Trulia发送一个通知栏消息去提醒它们停止。这种量身定制的通知能够帮助用户在完美的时间打开房间经营。 SuperPlayer Music,在另一个方面，用户利用我们的快照API和围栏API去建议完美的音乐和你当前的心情匹配，无论你是刚刚完成了一项跑步并开始舒展、是坐长途车起来、还是刚刚离开健身房，它们的助理能够理解你的上下文并建议正确的播放列表给你。 我们最初设置的信标，我们的合作者真棒，我们才刚刚开始使用意识API，加入我们的旅程去构建量身定制的体验到你的应用中，通过使用Google Awareness API developer documentation(Google意识API开发者文档)获得开始，同时可以通过观看我们的Google I/O专题学习更多. 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 恢复移动视觉操作并添加文本API]]></title>
      <url>%2F2016%2F06%2F28%2Fandroid-mobile-vision-text-api%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Android Mobile Vision restores operation and adds Text API 在图片和视频中查找对象作为一个重要的核心，对于Android设备，在Google Play服务9.2版本上已经恢复了移动视觉操作。 在Google Play服务9.2这个新版本上，修复了一个在之前版本上存在的下载问题，导致了一个服务停止运行。 我们也高兴的宣布了文本API，对于移动视觉操作的一个新的组件。 这个文本API的光学字符识别技术，在图片中读取拉丁字符的文本（如：英语、西班牙语、德语、法语等等），返回文本以及组织结构(段落、行、字)。移动视觉操作现在能够： 组织包含文本的照片 自动化处理烦琐的数据录入，对于信用卡、数据和名片。 翻译文档（跟随Cloud Translate API(云端翻译API)） 跟踪真实的物体，比如在地铁列车内读取一些数字 提供无障碍特性 如果你想快速的开始，你可以尝试我们的codelab(代码实验室)，利用这儿的应用程序，将会在一个小时内获得Android 开发者阅读文本。 喜欢移动视觉面部识别操作和条码组件，对于实时应用，在设备上运行文本API是适宜的。对于更多的信息，在Mobile Vision Developer site(移动视觉开发者站点)检出。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android N对安全加密提供者已弃用]]></title>
      <url>%2F2016%2F06%2F10%2Fsecurity-crypto-provider-deprecated-in-android-n%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Security “Crypto” provider deprecated in Android N 如果你的安卓应用程序使用的是SHA1PRNG算法从加密提供者那里取得的密钥，你必须开始使用一个真正的密钥导出函数,然后可能需要重新加密你的数据。 Java加密体系结构允许开发者创建像密码一样的一个类的实例，或者是生成伪随机数，像这样去调用它: 1SomeClass.getInstance("SomeAlgorithm", "SomeProvider"); 或者更简单通熟些: 1SomeClass.getInstance("SomeAlgorithm"); 对于这个实例， 12Cipher.getInstance(“AES/CBC/PKCS5PADDING”); SecureRandom.getInstance(“SHA1PRNG”); 在Android上，我们不建议指定提供者。一般来说,任意调用Java加密扩展(JCE)API指定一个提供者，如果这个提供者是包括在应用程序里，或者说这个应用程序能够处理可能出现的ProviderNotException异常，也应该仅仅能完成这些。 不幸的是，很多应用程序都依赖于现在已经被移除了的”加密”提供者，对于一个密钥派生出来的反模式 这个提供者只能被提供一些为SecureRandom实例去实现的“SHA1PRNG”算法接口，问题是SHA1PRNG算法不是强加密，在使用基于PHP和Debian OpenSSL的伪随机序列和实验的统计距离的测试,8.1那部分，Yongge Want 和 Tony Nicol，指出该”随机”数列,以二进制形式考虑,朝0偏移返回，而且该偏移恶化的程度取决于种子。 结果是，在Android N中我们干脆弃用依赖于以“SHA1PRNG”算法去实现的接口和该加密提供者。我们在几年前使用加密安全存储凭据预先去覆盖使用SecureRandom派生出来的密钥产生的那些问题。然而，鉴于要继续使用它，我们将在这里重温一下。 该提供者有一个常见但是不正确的使用方法，就是通过使用密码作为种子来推导出加密密钥。SHA1PRNG接口有一个漏洞缺陷，如果setSeed()在获得输出之前被调用，那么就使他正确了。这个漏洞缺陷已经被用于密码作为种子派生加密密钥的关键，然后使用“随机”输出关键的密钥（其中,”随机”在这句话里的意思是“可以预测和若加密”），然后这种密钥可以用于加密和解密数据。 接下来，我们解释如何正确的导出密钥，以及如何解密已经进行不安全密钥加密的数据。这儿也有一个完整的例子,包括了一个帮助类去使用已经弃用SHA1PRNG功能，解密数据的唯一目的将不可用。 密钥可以通过以下方式得到： 如果你是通过从磁盘上读取一个AES的密钥，只是存储实际的密钥，你可以从通过使用执行字节AES生成SecretKey密钥： 1SecretKey key = new SecretKeySpec(keyBytes, "AES"); 如果您使用密码来获得一个密钥，参照Nikolay Elenkovd的这篇优秀教程，一个好的经验法制是腌制的大小应该和密钥输出的大小一致，它看上去就像是这样: 12345678910111213141516171819202122/* User types in their password: */ String password = "password"; /* Store these things on disk used to derive key later: */ int iterationCount = 1000; int saltLength = 32; // bytes; should be the same size as the output (256 / 8 = 32) int keyLength = 256; // 256-bits for AES-256, 128-bits for AES-128, etc byte[] salt; // Should be of saltLength /* When first creating the key, obtain a salt with this: */ SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltLength]; random.nextBytes(salt); /* Use this to derive the key from the password: */ KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength); SecretKeyFactory keyFactory = SecretKeyFactory .getInstance("PBKDF2WithHmacSHA1"); byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();SecretKey key = new SecretKeySpec(keyBytes, "AES"); 就是这样，你也不需要做其他的任何事情。 为了使过渡数据更容易，我们覆盖开发者的情况，有一个不安全的密钥加密的数据，它是每次从一个密码那里派生出来的。你可以在示例应用程序中使用帮助类InsecureSHA1PRNGKeyDerivator去派生出密钥: 12345678private static SecretKey deriveKeyInsecurely(String password, intkeySizeInBytes) &#123; byte[] passwordBytes = password.getBytes(StandardCharsets.US_ASCII); return new SecretKeySpec( InsecureSHA1PRNGKeyDerivator.deriveInsecureKey( passwordBytes, keySizeInBytes), "AES"); &#125; 然后，你可以使用安全的派生出的密钥按照上面的所述的重新加密数据，并从此过上幸福的生活。 注意1:作为一个临时的措施去维持应用重新工作，我们决定了在目标SDK版本为Mashmallow(API23)及其低版本还是为应用程序创建示例，请不要在Android SDK中存在依赖加密提供者，我们的计划是在未来会将其完全删除。注意2:因为该系统很多部分都承担了SHA1PRNG算法的存在，当一个SHA1PRNG实例请求和提供者没有指定，我们将返回一个OpenSSLRandom的实例，这是从OpenSSL的衍生出随机数的一个强有力的来源。 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android N 中的 Notification 通知]]></title>
      <url>%2F2016%2F06%2F09%2FNotifications-In-Android-N%2F</url>
      <content type="text"><![CDATA[原文来自: Android Developers Blog —— Notifications in Android N Android 通知往往是在你的Android应用和用户之间制造或打破而相互作用。为了提供更好的用户体验，Android N上的通知已经接收到视觉的更新，对于自定义视图更好的支持，以及直接回复形式的扩展功能，一个全新的消息风格，和捆绑通知 相同的通知，新的面貌首先最明显的变化就是通知的默认外观已经显著变化，许多被周围的通知扩散区域已经折叠到了一个新的标题里面，和你的应用的应用图标以及名字固定通知。这个变化确保了标题、文本和大图标被给予最大量的空间的可能性，并且其结果就是，现在的通知通常稍大了，更容易阅读。 鉴于单行标题，这是比以往的信息的有用性更重要，当你的目标是Android N 的时候，默认的情况下时间会被隐藏，不会显示出来—— 如果你有一个时间危机的通知，比如说是一个消息应用程序，你能够使用setShowWhen(true)重新开启它。此外，内容下面一小行的文字将会优先于你设置的任何内容信息:只有当你指定Android N 之前的早期版本才会同时出现。在所有的情况下，确保内容下面一小行的文字是符合标题且有用的——比如说，如果用户仅仅只有一个账户，不要添加一个账户邮箱地址作为你的内容下面一小行的文字。 通知操作也得到了重新的设计，现在以下的通知条条目在视觉上是不同的。 你会注意到，图标都没有出现在新的通知;而是提供了标签本身在通知栏有限的空间里更多的空间。然而，通知操作图标仍然需要请求并继续在Android旧版本设备上使用，比如说Android Wear. 如果你将利用NotificationCompat.Builder构建一个你的通知，你可以在那儿使用标准样式风格，你将会得到全新面貌和感觉，默认的情况下，不需要进行更改代码的请求。 对于自定义视图提供更好的支持如果你不是从自定义RemoteViews来代替构建你的通知，适配任何全新风格就已经成为挑战了。从一个通知正文+标题，利用全新的标题、伸缩特性、动作、和大图标定位作为一个独立元素，我们将介绍一个全新的DecoratedCustomViewStyle和DecoratedMediaCustomViewStyle去提供所有的这些元素，允许你用新的setCustomContentView()方法只关注内容。 这也确保了未来的外观和感觉应该被显著简单的适配，在应用那边不需要修改任何代码这些样式将平台一起进行更新。 直接回复当通知已经有了可以启动一个Activity或者在使用一个Sevice或者BroadcastReciver在后台工作的操作，直接回复（Direct Reply）允许你构建一个动作，利用通知操作直接接受通知单行文本输入。 直接回复使用了相同的RemoteInputAPI——最初是在Android Wear里引人的——对于标记一个能够接受让用户直接输入。标记一个动作(Action)作为能够直接接收来自用户的输入。 该RemoteInput本身包含像将被用于以后检索的输入，和用户开始输入之前所显示的提示文本的关键信息。 12345678// Where should direct replies be put in the intent bundle (can be any string)private static final String KEY_TEXT_REPLY = "key_text_reply";// Create the RemoteInput specifying this keyString replyLabel = getString(R.string.reply_label);RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY) .setLabel(replyLabel) .build(); 一旦你已经构建了RemoteInput,它可以通过适当命名的addRemoteInput()方法连接到你的Action操作。你可能会考虑调用setAllowGeneratedReplies(true)方法去开启Android Wear 2.0产生Smart Reply(智能回复)的选择，当它可用的时候,能使用户更容易迅速作出反应。 123456// Add to your action, enabling Direct Reply for itNotificationCompat.Action action = new NotificationCompat.Action.Builder(R.drawable.reply, replyLabel, pendingIntent) .addRemoteInput(remoteInput) .setAllowGeneratedReplies(true) .build(); 请记住，pendingIntent被传递到你的Action动作应该是一个Activity，在Marshmallow以及更低版本的设备上是不支持直接回复功能(你将希望锁屏,开启一个Activity,有一个焦点输入框让用户可以直接在里面输入回复)，应该是一个Service（如果你需要这样做需要在一个另外的线程）或者是BroadcastReceiver（它运行在UI主线程）在Android N 设备上，因此，甚至从锁屏背景下的文本输入这么一个流程（这儿是一个另外的用户从系统设置中去控制一个被锁的设备直接回复启用/禁用） 在你的Service或者BroadcastReceiver里提取文本输入，可以使用到的帮助:RemoteInput.getResultsFromIntent() 方法 1234567private CharSequence getMessageText(Intent intent) &#123; Bundle remoteInput = RemoteInput.getResultsFromIntent(intent); if (remoteInput != null) &#123; return remoteInput.getCharSequence(KEY_TEXT_REPLY); &#125; return null; &#125; 之后你将处理文本，你必须更新通知，这个是隐藏UI直接回复，应该作为一种技术来确认用户他们答复接收和正确处理的触发。 对于多数模板，这都应该涉及使用追加答复到通知的底部新的setRemoteInputHistory()方法，直到主要内容被更新的其他答复被追加到历史(比如说其他人回复) 然而，如果你将构建一个消息类型的应用程序，预计来回交流对话，你应该使用MessagingStyle并使附加消息追加到它上面。 MessagingStyle 我们已经对正在进行对话进行了优化，并使用了新的MessagingStyle进行直接回复的体验 这个样式风格提供了内置的通过addMessage()返回添加多个消息格式的方法。每一个条消息支持传入文本本身，时间戳和消息的发送者（因此很容易支持群组对话） 123456builder.setStyle(new NotificationCompat.MessagingStyle("Me") .setConversationTitle("Team lunch") .addMessage("Hi", timestampMillis1, null) // Pass in null for user. .addMessage("What's up?", timestampMillis2, "Coworker") .addMessage("Not much", timestampMillis3, null) .addMessage("How about lunch?", timestampMillis4, "Coworker")); 你将会注意到，这种风格对于具体的消息表示一流的支持从用户和他们填写的名字(使用”我”这种情况)，并设置一个可选的对话标题。当这个可以手动的使用一个BigTextStyle，通过Android Wear 2.0 使用这种风格的用户，将会获得直接内嵌的行来响应，抛弃了踢出来扩展通知来看，制造了一个无缝体验，而无须构建一个完整的可穿戴的应用程序。 捆绑通知一旦你使用了一个全新的视觉设计去构建一个伟大的通知，直接回复、信息风格、和我们以前所有的最佳实践,考虑整体的通知体验是非常重要的,特别是如果你发布多个通知(说，每个正在进行会话或者每个新的电子邮件线程之间) 捆绑通知(Bundled notificaiton)提供了两全其美：当用户正在寻找其他通知一个单条的摘要通知或者希望在所有的通知上同时操作展开组操作个体通知（包括使用操作和直接回复） 如果你将要构建Android Wear通知栈，和这里的API使用方法完全相同，只需要添加setGroup())到每一个通知就能将这些通知捆绑在一起了。你不局限于一组，所以捆绑通知恰如其分。对于电子邮件应用程序，你可以考虑每个帐户一个捆绑的实例。 创建一个摘要通知(summary notification)也是重要的，这个摘要通知，通过 setGroupSummary(true)，它仅仅是通知出现在Mashmallow及其低版本设备上，应该(你猜对了)总结所有个人通知。这是一个使用InboxStyle最合适的时候。虽然使用它不是一个要求。在Android N及其更高版本的设备上，一些信息(比如说subText，subtext, content intent, and delete intent)是从摘要的通知中提取生产倒塌通知捆绑的通知，所以你应该继续产生的所有API级别的摘要通知。 为了提高在Android N个器件的整体用户体验，发布4个或者更多通知没有组的通知，这些通知将会被自动捆绑在一起 N是为了通知通知在Android上已经渐进增强的稳定区了。从Gingerbread时代的一个敲击目标到可以展开的通知、操作动作、媒体风格，以及现在的特性，比如直接回复和捆绑通知,通知在Android上所有用户体验中扮演了一个重要的部分。 利用现在许多新的工具去使用（NotificationCompat帮助向后兼容）,我很高兴地看到你如何来使用它们去#构建更好的应用程序 以上是对Anroid 官网博客文章的翻译，如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Wear 真机调试&创建第一个应用]]></title>
      <url>%2F2016%2F06%2F08%2FAndroid-Wear-create-first-demo%2F</url>
      <content type="text"><![CDATA[两年前，Android Wear刚出来的时候，我耐不住性子折腾新技术，就开始去把玩Android Wear。我当时还买不起真机，就用模拟器测试，2014年的那天也是端午佳节，我写了Android Wear第一个小例子。去年Moto 360 1 Gen 降价了，于是就入手了一台，准备开始来做Android Wear的App测试，然后呢，事实上就一直没有时间去做相关的开发测试，（是懒了？还是真的没时间？）好了，现在决定开始来着手，就从下面的例子开始吧。 调试前的准备 操作系统：Ubuntu 16.04 LTS开发环境：Android Studio 2.2 preview 2 (version:Linux)手持设备：Google Nexus 5手表设备：Moto 360 1 Gen手持系统：Android 6.0.1(MOB30M)手表系统：Android Wear 1.4.0.2580363 (Android 6.0.1) 创建项目1、启动Android Studio，新建一个项目工程AndroidWearApp 2、复选框选中手机和手表两个选项:选中Phone and Tablet 并且 Minimum SDK 选择 API15:Android 4.0.3(IceCreamSandwich)选中Wear并且Minimum SDK 选择 API20:Android 4.4(KitKat Wear) 3、Add an Activity to Mobile,我们选择添加默认的Empty Activity显示空Activity 4、Add an Activity to Wear 我们选择添加Blank Wear Activity显示通知 5、成功创建项目完成，打开Wear模块下的布局文件 开启设备调试开启手机端USB调试开关打开系统设置，查看是否有开发者选项，如果有直接进去打开开发者选项，开启USB调试开关；如果没有，在设置最下面的关于手机中，点击底部系统版本信息7次，会弹出打开成功的提示。按返回键回到上一级，可以看到开发者选项,打开开发者选项，开启USB调试开关。 开启手表端Bluetooth调试开关按右侧的物理键点亮屏幕，屏幕向左滑动唤出菜单，上下滚动找到设置选项点击它，然后滚动到底部看是否有开发者选项,如果有，进去开启USB调试开关。；如果没有，点击设置底部的关于，然后点击系统版本信息7次，就会出现开发者选项。进入开发者选项,开启USB调试开关。 开启调试会话连接手机USB数据线连接到电脑，在手机端打开蓝牙，运行Android Wear应用（确保你的手机手表已经连接）。点击Android Wear右上角的齿轮图标进入设置（Settings） 开启通过蓝牙调试打开设置（Settings）底部的通过蓝牙调试（Debugging over Bluetooth）切换按钮。你可以看到连接状态: Host: disconnected Target: connected 确保手机已经链接到电脑，并执行adb命令： 1adb forward tcp:4444 localabstract:/adb-hub; adb connect localhost:4444 你就可以看到刚才连接状态变成了 Host: connected Target: connected 调试应用我们回到Android Studio，我们可以看到 Android Monitor下面已经连接上了两个设备，一个是我的手持设备LGE Nexus 5 Android 6.0.1,API 23,另一个是我的手表设备Motorola Moto 360 Android 6.0.1,API 23,标志着我的手表手机和Android Studio三者之间都互通了。 下面需要到wear模块下Java代码进行修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends Activity &#123; private TextView mTextView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final WatchViewStub stub = (WatchViewStub) findViewById(R.id.watch_view_stub); stub.setOnLayoutInflatedListener(new WatchViewStub.OnLayoutInflatedListener() &#123; @Override public void onLayoutInflated(WatchViewStub stub) &#123; mTextView = (TextView) stub.findViewById(R.id.text); mTextView.setText("点我创建通知"); mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int notificationId = 001; String eventTitle = "端午将至"; String eventLocation = "祝大家端午节快乐！\n生活“粽”快乐！\n样样“粽”美好！"; // Build intent for notification content Intent viewIntent = new Intent(MainActivity.this, MainActivity.class); PendingIntent viewPendingIntent = PendingIntent.getActivity(MainActivity.this, 0, viewIntent, 0); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(MainActivity.this) .setSmallIcon(R.mipmap.googledev) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.googledev)) .setContentTitle(eventTitle) .setContentText(eventLocation) .setContentIntent(viewPendingIntent); // Get an instance of the NotificationManager service NotificationManagerCompat notificationManager = NotificationManagerCompat.from(MainActivity.this); // Build the notification and issues it with notification manager. notificationManager.notify(notificationId, notificationBuilder.build()); &#125; &#125;); &#125; &#125;); &#125;&#125; 点击Android Monitor下的设备，选中手表Motorola Moto 360 Android 6.0.1,API 23，点击Android Studio上的运行，App即可会自动安装到手表上，稍微有点慢耐心等下就好。 点击Activity上的TextView创建通知，回到主界面，往上滑动就能看到，刚刚创建的手表通知消息 卸载调试的应用执行命令 “adb -s localhost:4444 uninstall 包名” 即可，如： 1adb -s localhost:4444 uninstall com.example.shoewann.androidwearapp 这样，再看手表上就没有那个调试程序了。 以上简单的介绍了如何在使用真机创建调试Android Wear可穿戴设备，后续继续总结。如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Firebase特性之崩溃报告]]></title>
      <url>%2F2016%2F06%2F06%2FCrash-reporting-in-Firebase%2F</url>
      <content type="text"><![CDATA[在2016年的Google IO大会上，Google 公布了若干有关Firebase有意思的新特性。全新的Firebase添加了全新的工具，将成为统一移动应用开发的平台，帮助开发者快速开发，提高应用的开发质量，吸引用户和从应用中盈利。你可以从Firebase新官网和YouTube视频查看更多。 在Firebase更新的一些新特性包括: Firebase 分析 Firebase 云信息 Firebase 测试实验室和崩溃报告 Firebase 通知、动态链接、App 索引、广告、邀请等等 在这里文章中，我们来共同学习一下如何在Androids上使用Firebase的崩溃报告。 如何使用？ Firebase 3.0 需要运行在Google服务9.0或者更高的环境上，需要将Firebase添加到Android Studio中，你需要执行一下的操作步骤: 请求前的准备确保你的开发环境已经满足于以下的这些前提条件: 需要运行在一个支持Google服务是9.0.0或者更高的Android设备上 需要Android SDK 管理器中已经安装了Google 服务的相关插件文件，且是3.0.0或者更高版本。 需要Android Studio 的版本是1.5或者更高版本。 需要有一个Android项目，可以是已存在的或者新项目，同时拿到它的包名备用。 添加Firebase到应用这一步，需要添加Firebase到你的应用中，你需要到Firebase console上去创建一个Firebase的项目。 点击Create New Project（如果你开始一个新的项目）或者import Google Project（如果你导入一个已经存在的项目），我这里创建一个新的项目。 Firebase支持多平台，Android、IOS、Web.我们这里是以Android为例 现在，在你的APP应用里面，点击Add Firebase to your Android app 将会弹出一个对话框让你输入: 包名和SHAI SHAI的获取办法： keytool -exportcert -list -v \-alias androiddebugkey -keystore %USERPROFILE%.android\debug.keystore (Windows) keytool -exportcert -list -v \-alias androiddebugkey -keystore ~/.android/debug.keystore （mac/linux） 我的系统环境是linux，故使用后者命令，在终端执行并获得SHAI： 将包名和SHAI填入输入框内,点击ADD APP，随后你将会下载一个google-services.json的配置文件，根据页面提示，放到项目里指定位置。 将google-services.json文件放到project层级下的app目录下: 添加SDK到应用你的应用中要使用Firebase,你需要添加和设置SDK到你的应用中去，首先，添加以下行到你的项目根下的builde.gradle文件中去: 123456buildscript &#123; dependencies &#123; // Add this line classpath 'com.google.gms:google-services:3.0.0' &#125;&#125; 然后在你的app模块的build.gradle文件中，在文件的底部应用这个Google服务的插件你的builde.gradle应该是这个样子的： 123456789apply plugin: 'com.android.application' android &#123; // ... &#125; dependencies &#123; // ... &#125; // ADD THIS AT THE BOTTOM apply plugin: 'com.google.gms.google-services' 然后点击Sync now同步一下文件 设置崩溃报告现在，到了设置崩溃报告了，你需要添加Firebase崩溃报告依赖，你需要到你模块的build.gradle文件中去添加如下行: 1compile 'com.google.firebase:firebase-crash:9.0.1' 那么你的build.gradle文件大概就是这个样子: apply plugin: 'com.android.application' android { // ... } dependencies { // ... compile 'com.google.firebase:firebase-crash:9.0.1' } // ADD THIS AT THE BOTTOM apply plugin: 'com.google.gms.google-services' 然后点击Sync now同步一下文件 创建一个崩溃报告以上的操作已经完成了所有的配置，现在我们来创建一个崩溃报告。 我在项目的MainActivity中这样定义，模拟测试一个java.lang.NullPointerException的崩溃异常的情况: 定义一个TextView，但是不给它实例化对象,此时Textview对象为null，然后给它赋值一个字符串显示，给一个为空的对象赋值就会抛出java.lang.NullPointerException异常，以下是测试代码 当程序运行后，log中抛出了异常，但是程序没有崩溃退出,以下是本地log: 回到Firebase控制台查看，点击左侧的crash,大于20分钟左右，就能看到上传的java.lang.NullPointerException崩溃报告 点击上图异常日志中的超链接，可以跳转到以下界面,在这里可以看到java.lang.NullPointerException相关的详细数据等 这里可以看到测试的java.lang.NullPointerException具体行数在MainActivity.onCreate(MainActivity.java:18) 以上简单的介绍了如何在App应用中使用Firebase崩溃日志报告的相关内容，有关Firebase的其他特性，后续总结。如果不足，欢迎指正，谢谢。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 网络通信之——Socket]]></title>
      <url>%2F2016%2F06%2F02%2FAndroid-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8B%E2%80%94%E2%80%94Socket%2F</url>
      <content type="text"><![CDATA[Socket,又称“套接字”，是网络上运行的两个程序间双向通讯的一端，它既可以接受请求，也可以发送请求，利用它可以较为方便的编写网络上的数据的传递。在java中，有专门的socket类来处理用户的请求和响应。利用SOCKET类的方法，就可以实现两台计算机之间的通讯。Java中能够接受其他通信实体连接请求的类是ServerSocket类，该对象用于监听来自客户端Socket的连接。如果没有连接，它将一直处于等待的状态。 TCP的使用 TCP协议被称着一种端对端的协议，这是因为它为两台计算机之间的连接起了重要作用。当一台计算机需要与另外一台远程计算机连接时，TCP协议会让它们建立一个链接，用于发送和接收数据的虚拟链接。 客户端（client）: 发送数据和接收数据 ——&gt;Socket服务端（server）: 负责去分发以处理相关数据 ——&gt;ServerSocket 如何建立一个服务端123456789//创建一个ServerSocket,用于监听客户端Socket的连接请求ServerSocket serverSocket = new ServerSocket(8080);//采用循环不断的接受来自客户端的请求while(true)&#123; //每当接受的客户端Socket的请求，服务端也对应产生一个 Socket socket = serverSocket.accept(); //下面就可以进行Socket通信了 .........&#125; 如何建立一个客户端1234//创建连接到本机、8080端口的Socket Socket socket = new Socket("192.168.1.1", 8080);//下面就可以进行Socket通信了 ......... 简单通信示例 一个简单的示例，客户端界面上一个文本编辑框、一个按钮和一个文本显示。客户端输入内容在文本编辑框，然后点击按钮发送到服务器，服务器然后再返回给客户端，显示到文本显示控件上，完成客户端与服务器的通信。 服务器 SocketServer.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class SocketServer implements Runnable &#123; //创建一个ServerSocket对象 private ServerSocket serverSocket; //创建一个Socket对象 private Socket client; public void run() &#123; try &#123; //实例化ServerSocket对象,设置服务端端口8080 serverSocket = new ServerSocket(8080); System.out.println("服务器已启动，等待客户端连接..."); while (true) &#123; //不断循环，接受客户端的访问 client = serverSocket.accept(); System.out.println("客户端已连接"); System.out.println("============"); try &#123; // 接收客户端信息 BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); String str = in.readLine(); System.out.println("客户端:" + str); // 向客户端发送信息 PrintWriter out = new PrintWriter(new BufferedWriter( new OutputStreamWriter(client.getOutputStream())), true); System.out.println("服务器发送:" + str); out.println("服务器：" + str); //本次会话完成,关闭输入输入出流 in.close(); out.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; finally &#123; //关闭输入Socket对象 client.close(); System.out.println("============"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param args */ public static void main(String[] args) &#123; //创建线程 Thread thread = new Thread(new SocketServer()); //开启线程 thread.start(); &#125;&#125; 客户端XML文件 activity_main.xml Java 代码 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.example.shoewann.socketclient;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; private android.widget.EditText editText; private android.widget.Button button; private android.widget.TextView textView; private static final String IP_ADDRESS = "192.168.1.189"; private static final int IP_PORT = 8080; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initData() &#123; this.button.setOnClickListener(this); &#125; private void initView() &#123; this.textView = (TextView) findViewById(R.id.textView); this.button = (Button) findViewById(R.id.button); this.editText = (EditText) findViewById(R.id.editText); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: final String message = editText.getText().toString(); editText.getText().clear(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Socket socket = new Socket(IP_ADDRESS, IP_PORT); //客户端=&gt;向服务器=&gt;发送信息 PrintWriter out = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream())), true); Log.e(TAG, "Socket send Message:==&gt;" + message); out.println(message); //客户端=&gt;接收=&gt;服务器=&gt;返回信息 BufferedReader br = new BufferedReader( new InputStreamReader(socket.getInputStream())); String msg = br.readLine(); Log.e(TAG, "Socket receiver Message:==&gt;" + message); //实例化Handler类和Message发送消息给主线程更新UI MyHandler handler = new MyHandler(getMainLooper()); Message mMessage = handler.obtainMessage(); mMessage.what = 0x123; mMessage.obj = msg; handler.sendMessage(mMessage); //注意最后要关闭输入输出流 out.close(); br.close(); //关闭socket对象 socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.w(TAG, e.toString()); &#125; &#125; &#125;).start(); break; default: break; &#125; &#125; class MyHandler extends Handler &#123; public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 0x123: //获得消息中服务器返回的数据,显示到UI上 if (msg.obj != null) &#123; textView.setText(msg.obj.toString()); &#125; else &#123; textView.setText("服务器返回数据错误"); &#125; break; default: break; &#125; &#125; &#125;&#125; 效果图 客户端发送前： 服务端收到信息并返回： 客户端收到服务器返回的信息： 简易聊天室示例 以下的示例简单的实现你一个简易的聊天室效果 服务器 SocketThread.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SocketThread implements Runnable &#123; //定义处理当前线程的Socket Socket socket=null; //该线程处理Socket所对应的输入流 BufferedReader bf=null; public SocketThread(Socket s)&#123; this.socket=s; try &#123; //初始化该socket对应的输入流 bf=new BufferedReader(new InputStreamReader(s.getInputStream(),"utf-8")); &#125;catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); System.out.println("SocketThread UnsupportedEncodingException :===&gt;"+e.getMessage()); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("SocketThread Exception :====&gt;"+e.getMessage()); &#125; &#125; public void run() &#123; // TODO Auto-generated method stub try &#123; String content=null; while ((content=readMessageFromeClient())!=null) &#123; //遍历socketList中的每一个socket对象，将读取到的内容向每个socket发送一次 for (Socket socket : AndroidThreadServer.socketList) &#123; //创建输出流对象 OutputStream outputStream; outputStream=socket.getOutputStream(); System.out.println(content+"\n"); outputStream.write((content+"\n").getBytes("utf-8")); &#125; &#125; &#125; catch (IOException e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("Run IOException :===&gt;"+e.getMessage()); &#125; &#125; private String readMessageFromeClient()&#123; try &#123; return bf.readLine(); &#125; catch (IOException e) &#123; //如果发生了异常，表示客户端已近关闭，应该删掉socket AndroidThreadServer.socketList.remove(socket); e.printStackTrace(); System.out.println("readMessageFromeClient IOException :===&gt;"+e.getMessage()); &#125; return null; &#125;&#125; AndroidThreadServer.java 1234567891011121314151617181920212223242526public class AndroidThreadServer &#123; //定义保存所有socket的list对象 public static List&lt;Socket&gt; socketList=new ArrayList&lt;Socket&gt;(); public static void main(String[] args) &#123; try &#123; //创建socket对象，使用端口8080 ServerSocket serverSocket=new ServerSocket(8080); //不断的循环，接受客户端的访问 while (true) &#123; //创建Socket对象，使用accept()方法不断的创建 Socket socket=serverSocket.accept(); //将socket对象添加到list集合里 socketList.add(socket); //客户端连接成功后启启动一条SocketThread线程为该客户的服务 new Thread(new SocketThread(socket)).start(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); System.out.println("AndroidThreadServer Exception:===&gt;"+e.getMessage()); &#125; &#125;&#125; 客户端XML 布局 activity_main.xml Java 代码 ClientThread.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ClientThread implements Runnable &#123; private static final String TAG = "ClientThread"; //声明Socket对象 private Socket mSocket = null; //声明Handler对象 private Handler mHandler = null; //声明BufferedReader对象 private BufferedReader bf = null; public ClientThread(Socket socket, Handler handler) &#123; this.mSocket = socket; this.mHandler = handler; try&#123; //获取BufferedReader 对象 bf=new BufferedReader(new InputStreamReader(socket.getInputStream())); &#125;catch (IOException e)&#123; e.printStackTrace(); Log.w(TAG, "ClientThread IOException: ====&gt;"+e.getMessage()); &#125; &#125; @Override public void run() &#123; String content=null; try &#123; //循环读取内容 while ((content=bf.readLine())!=null)&#123; //构建消息对象 Message msg=mHandler.obtainMessage(); //设置消息对象模式与内容 msg.what=0x123; msg.obj=content; mHandler.sendMessage(msg); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); Log.w(TAG, "Run IOException: ====&gt;"+e.getMessage()); &#125; &#125;&#125; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = "MainActivity"; public android.widget.TextView tvshow; private android.widget.EditText edinput; private android.widget.Button btnsend; private static final String IP_ADDRESS = "192.168.1.189"; private static final int IP_PORT = 8080; private OutputStream output = null; private Socket mSocket = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); iniData(); &#125; private void initView() &#123; this.btnsend = (Button) findViewById(R.id.btn_send); this.edinput = (EditText) findViewById(R.id.ed_input); this.tvshow = (TextView) findViewById(R.id.tv_show); &#125; private void iniData() &#123; this.btnsend.setOnClickListener(this); SocketHandler handler = new SocketHandler(Looper.getMainLooper()); initSocket(handler); &#125; public void initSocket(final Handler handler) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; mSocket = new Socket(IP_ADDRESS, IP_PORT); //启动子线程,每一个线程处理对应的socket new Thread(new ClientThread(mSocket, handler)).start(); //实例化输出流对象 output = mSocket.getOutputStream(); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); Log.w(TAG, "initSocket tUnknownHostException : ==&gt; " + e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.w(TAG, "initSocket IOException : ==&gt; " + e.getMessage()); &#125; &#125; &#125;).start(); &#125; class SocketHandler extends Handler &#123; public SocketHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //判断是否有子线程传递过来的消息 switch (msg.what) &#123; case 0x123: //将服务器的消息追加到textview控件上进行显示 MainActivity.this.tvshow.append(msg.obj.toString()+"\n"); break; &#125; &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_send: try &#123; Date date=new Date(); DateFormat format=new SimpleDateFormat("HH:mm:ss"); String time=format.format(date); //将文本输入框的文本信息写入流 output.write((getlocalip()+"\t\t["+time+"]\n"+edinput.getText().toString() + "\n").getBytes()); //将文本输入框内容置空 edinput.getText().clear(); //edinput.setText(""); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); Log.w(TAG, "onClick UnknownHostException : ==&gt; " + e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); Log.w(TAG, "onClick IOException : ==&gt; " + e.getMessage()); &#125; break; &#125; &#125; private String getlocalip()&#123; WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); Log.d(TAG, "int ip "+ipAddress); if(ipAddress==0)return null; return ((ipAddress &amp; 0xff)+"."+(ipAddress&gt;&gt;8 &amp; 0xff)+"." +(ipAddress&gt;&gt;16 &amp; 0xff)+"."+(ipAddress&gt;&gt;24 &amp; 0xff)); &#125;&#125; 效果图 客户端 A： 客户端 B： 服务端： 以上简单的介绍了Socket网络通信相关内容，如果不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity多级跳转带返回值]]></title>
      <url>%2F2016%2F05%2F31%2FActivity%E5%A4%9A%E7%BA%A7%E8%B7%B3%E8%BD%AC%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
      <content type="text"><![CDATA[我们最常用的就是A、B两个activity跳转传值，有时还会遇到A、B、C三个页面传值，如果A——&gt;B——&gt;C,如何将C页面的数据直接返回给A？ 针对这个问题，以前遇到你多次了。为此，觉得有必要记录下来，好了，来用下面的例子说明具体操作 首先新建一个项目，创建A、B、C三个Activity，每个Activity上有一个TextView和一个Button，点击A界面的按钮传值到B界面，点击B界面的按钮传值到C界面，点击C界面的按钮返回值到A界面，最终完成测试（在下面的示例中，暂时只考虑A——&gt;B——&gt;C——&gt;A这样的情况） MainActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = "MainActivity"; private android.widget.Button button; private android.widget.TextView textView; private final int MAINACTIVITY_REQUEST_CODE=1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); } private void initData() { this.button.setOnClickListener(this); this.textView.setText("我是MainActivity的数据"); } private void initView() { this.textView = (TextView) findViewById(R.id.textView); this.button = (Button) findViewById(R.id.button); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(this, SecondActivity.class); starter.putExtra("first","我是来自MainActivity的数据"); startActivityForResult(starter,MAINACTIVITY_REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode==Activity.RESULT_FIRST_USER){ if (requestCode==MAINACTIVITY_REQUEST_CODE){ if (data!=null){ textView.append("\n"+data.getStringExtra("threeth")); } } } } } SecondActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class SecondActivity extends AppCompatActivity implements View.OnClickListener{ private static final String TAG = "SecondActivity"; private android.widget.Button button2; private android.widget.TextView textView2; private final int SECONDACTIVITY_REQUEST_CODE=2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); initView(); initData(); } private void initView() { this.textView2 = (TextView) findViewById(R.id.textView2); this.button2 = (Button) findViewById(R.id.button2); } public void initData(){ if (getIntent()!=null){ textView2.setText(getIntent().getStringExtra("first")); } this.button2.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button2: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(this, ThreethActivity.class); starter.putExtra("second","我是来自SecondActivity的数据"); startActivityForResult(starter,SECONDACTIVITY_REQUEST_CODE); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (resultCode==Activity.RESULT_FIRST_USER){ if (requestCode==SECONDACTIVITY_REQUEST_CODE){ if (data!=null){ setResult(Activity.RESULT_FIRST_USER,data); finish(); } } } } } ThreethActivity.javapackage com.example.shoewann.activityintent; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; public class ThreethActivity extends AppCompatActivity implements View.OnClickListener{ private static final String TAG = "ThreethActivity"; private android.widget.Button button3; private android.widget.TextView textView3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_threeth); initView(); initData(); } private void initView() { this.textView3 = (TextView) findViewById(R.id.textView3); this.button3 = (Button) findViewById(R.id.button3); } public void initData(){ if (getIntent()!=null){ textView3.setText(getIntent().getStringExtra("second")); } this.button3.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button3: starter(); break; default: break; } } private void starter() { Intent starter = new Intent(); starter.putExtra("threeth","我是来自ThreethActivity的数据"); setResult(Activity.RESULT_FIRST_USER,starter); finish(); } } C —&gt; A 以上简单的介绍了Activity多级跳转带返回值的具体方法，如果不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux下adb出现no permissions问题]]></title>
      <url>%2F2016%2F05%2F31%2FLinux%E4%B8%8Badb%E5%87%BA%E7%8E%B0no%20permissions%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在linux下开发安卓的时候，有时候在连接USB调试的时候，系统出现adb no permissions 的问题，导致没有权限去调试程序？这种情况该如何处理呢？ 解决办法其实很简单，就是在终端执行下面几句adb命令即可 打开终端Linux下用Ctrl+Alt+T,打开Temimal终端 执行sudo1$ sudo su 然后回车，输入root下的密码，此时输入的密码是看不见的（退格键也属于一个密码字符），只管输入，输入完成后，回车键，如果成功的情况下就会输出下一条提示，以root@开头且以#结尾，否则就会提示你root下的密码输入错误，请重试。 执行 adb kill-server1# adb kill-server 执行 adb start-server1# adb start-server 然后下面会输出: 12* daemon not running. starting it now on port 5037 ** daemon started successfully * 以上简单的介绍了如何处理Linux下adb出现no permissions问题的具体方法，如果不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 使用自定义Font]]></title>
      <url>%2F2016%2F05%2F30%2FAndroid-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Font%2F</url>
      <content type="text"><![CDATA[Android系统为我们提供的一些字体的同时，我们也可以自定义字体。 让我们来看一下是如何使用自定义字体的具体方法 创建一个assets文件夹如果你没有，就需要创建一个 在你的Android Studio里，选中文件 ==&gt; 项目右键 ==&gt; New ==&gt; Folder ==&gt; Asstes Folder 默认继续，==&gt; Finish 创建一个font字体文件夹 asstes ==&gt; 右键 ==&gt; new ==&gt; Directory ==&gt; 名称填入“fonts” 创建fonts文件夹完成 复制字体到fonts文件夹下 比如Material Design需要用到的Roboto字体到这里下载,下载完成后解压,复制*.ttf自定义字体到fonts文件夹下 Java 方式你可以使用Java方式来自定义字体 TextView textView=(TextView) findViewById(R.id.tv_custom_font); Typeface tf=Typeface.createFromAsset(getAssets(),"fonts/Roboto-Black.ttf"); textView.setTypeface(tf); XML 方式你也可以使用XML的方式来自定义字体 创建一个自定义的TextView类/** * Created by shoewann on 5/30/16. */ public class MyCTextView extends TextView { public MyCTextView(Context context, AttributeSet attrs) { super(context, attrs); this.setTypeface(Typeface.createFromAsset(context.getAssets(),"fonts/Roboto-Black.ttf")); } } 这个构造方法接受两个参数： Context 上下文 一个设置XML属性，这儿将会被应用到一个全新的TextView上 定义一个自定义的XML&lt;com.example.shoewann.customfont.MyCTextView android:id="@+id/tv_custom_font" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="This is Custom font TextView" android:textSize="18sp" app:layout_constraintBottom_toBottomOf="@+id/activity_main" app:layout_constraintLeft_toLeftOf="@+id/activity_main" app:layout_constraintRight_toRightOf="@+id/activity_main" app:layout_constraintTop_toTopOf="@+id/activity_main" /&gt; 默认字体在哪儿呢？打开SDK下面的platforms文件夹，在下面你会看到你安装的Android API不同平台 任意打开一个平台的版本，比如android-19文件夹（你会在android-19/data/fonts下发现): 以上简单的介绍了两种方式实现使用自定义字体的具体方法，如果不足，欢迎指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android性能优化之——渲染篇]]></title>
      <url>%2F2016%2F05%2F29%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E7%AF%87%2F</url>
      <content type="text"><![CDATA[《Android 性能优化》学习课程是Google发布在Udacity(优城学院)的专题课程,它分别从渲染，运算与内存，电量几个方面介绍了如何去优化性能，在这之前国内腾讯的Android大牛——胡凯，对其翻译整理了一份专题博客。但是之前我一直没有博客，但是现在有了，我打算自己去学习课程，自己在他的基础上去完善总结一下相关的课程笔记，毕竟每个人获取知识的重点可能不一样。 今天就从性能优化——渲染篇，开始… 说到Android性能，不得不说一下光头哥Colt McAnlis这位大神，Colt McAnlis是在Google主要从事Android中性能相关工作的，我每次很喜欢看他讲，幽默诙谐，对Android性能方面有很深入的研究，也是我敬仰的Google大神之一 应用性能优化的步骤 获取信息 分析数据 采取行动 设计 vs 性能现在众多开发APP的公司，为了让App达到很炫丽的视觉冲击效果，会需要在界面上层叠很多的视图组件，很多开发者在开发中注重的基本上都是达到这样的功能效果仅此而已，大多数可能都不会去关心性能是如何的？ 只要App功能正常不出异常，那么这款App差不多就OK了，但是往往这样缺乏性能优化的App在用户的手上使用时，回出现各种卡顿、黑屏的情况，致使用户最终不得不卸载你的这款应用。所以我们在开发一款应用的时候，不仅要实现它的功能，性能也不要忽视。 系统会每隔16s重新绘制一次activity，1000ms/60hz=16.666ms/frame 如果在1000/60=16.67ms内没有办法把这一帧的任务执行完毕，就会发生丢帧的现象。丢帧越多，用户感受到的卡顿情况就越严重。 Android CPU 和 GPU导致卡顿的第一个原因就是：渲染 渲染操作通常依赖于两个核心组件：CPU 和 GPU CPU方面的因素：不必要的布局和失效 ，这些内容必须在视图层次结构中进行测量、清除并重新创建。一方面，重建显示列表的次数太多，另一方面花费太多的时间在作废视图层并进行不必要的重绘，使更新显示列表或者其他缓存资源时导致cpu工作过度，出现了卡顿。 GPU方面的因素：像素着色过程中，通过其他工具进行后去着色时浪费里GPU处理时间。 Activity的显示？ colt 说： 要想开发一款性能优越的应用，你必须了解底层是如何运行的。 Activity是如何绘制到屏幕上的？复杂的XML布局文件和标记语言是如何转化成用户能看懂的图像的？ 答案是：‘格栅化’操作 格栅化：将字符串、按钮、路径或者形状等拆分到不同的像素上在屏幕上进行显示。==&gt; GPU 完成这一操作 GPU使用一些指令的基础指令集，主要是多边形和纹理，也就是图片 CPU在屏幕上绘制图像前，会向GPU输入这些指令，这一过程通常使用的API就是Android的OpengGL ES UI对象 =&gt; CPU转换为多边形或者纹理 ==&gt; GPU格栅化 在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示比较复杂，需要先经过CPU换算成纹理，然后交给GPU进行渲染，返回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则存在一个更加复杂的操作流程。 为了能够使得App流畅，我们需要在每帧16ms以内处理完所有的CPU与GPU的计算，绘制，渲染等等操作。 渲染性能优化就是：尽可能地上传数据到GPU，然后尽可能长的在不修改的条件下保存数据 GPU性能问题瓶颈：过度绘制 过度绘制 定义：指的是屏幕上的某个像素点在同一帧的时间里被绘制里多次 工具：开发者选项 =&gt; “Debug GPU overdraw” ==&gt; show （1x （这个像素点被绘制了2次） 是蓝色，然后还有2x 3x 4x） 蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。 两种清除过度绘制的方法： 要从视图中清除哪些不必要的背景和图片，它们不会在最终渲染的图像中显示 对视图中重叠的屏幕区域进行定义，从而降低CPU和GPU的消耗 剪辑 剪辑：Android 设法避免绘制哪些最终界面中不显示的UI组件，你能确定某个对象会被完全阻挡，那就没必要去绘制它,这时候就需要剪辑 剪辑无法应对复杂的自定义View (比如纸牌层叠), 这时候就需要使用 Canvas.clipRect （ClipRect API 帮助系统识别出无需绘制的区域） DisplayList 定义： Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的，持有所有要交给GPU绘制到屏幕上的数据信息列表 请注意：任何时候View的绘制内容发生了变化，都需要重新执行DisplayList，并重新执行指令更新到屏幕上，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。 Hierarchy Viewer 打开步骤：Android Studio =&gt; Tools =&gt; Android =&gt; Android Devices Monitor Hierarchy的好用之处：它能帮助你从Android的角度去理解你的用户界面的结构，同时可以帮助你确定哪些视图是多余的 Venn图形图标,绿黄红三种颜色的圆点表示了渲染速度的快慢,最左边的圆点代表渲染管道的测量阶段，中间的表示布局阶段，最右边的表示渲染管道的绘制阶段 层级扁平化提升布局性能的关键点是尽量保持布局层级的扁平化，避免出现重复的嵌套布局。 以上就是个人对《Android 性能优化之——渲染篇》的主要内容进行的总结，后面有空继续总结下一篇性能优化的笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android官方UI自动化测试框架——Espresso]]></title>
      <url>%2F2016%2F05%2F24%2FAndroid%E5%AE%98%E6%96%B9UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Espresso%2F</url>
      <content type="text"><![CDATA[上周在美国山景城的Google公司，举办了一年一度的Google IO 大会，主要是发布一些新的产品和开发工具，以及接下来一年的发展方向。在其中也推出了Android Studio 2.2 预览版1，对其进行了强化，内置了部分新工具，比如Firebase、Espresso 测试记录器 、APK 分析器等等。正好无意中看到Espresso这部分，自己也没有使用过，那今天就来说说: Espresso ，也作为笔记记录一下 简介Espresso 测试工具，相对于其他工具，API更加精确。并且规模更小、更简洁并且容易学习。它最初是2013年GTAC大会上推出的，目标是让开发者写出更简洁的针对APP的UI测试代码。虽然针对的是开发者（Developer），但是对于测试人员来说也是可以用的。 官方文档网址： https://google.github.io/android-testing-support-library/docs/espresso/index.html 官方示例地址： https://github.com/googlesamples/android-testing 兼容性Espresso 支持以下API版本: Froyo (API 8)Gingerbread (API 10)Ice Cream Sandwich (API 15)Jelly Bean (API 16, 17 ,18)KitKat (API 19)Lollipop (API 21) 设置测试环境为你避免对测试效果的影响，需要关闭虚拟机或者物理设备上的系统动画的使用: 在你的设备上，设置 -&gt; 开发者选项 下关闭以下3个选项设置： 窗口动画缩放 -&gt; 关闭动画 过渡动画缩放 -&gt; 关闭动画 动画程序时长缩放 -&gt; 关闭动画 下载Espresso 确保你在SDK里面的Extra下已经安装了最新版本的Android Support Repository 打开你app的build.gradle文件，它通常不是位于第一个build.gradle文件，但是是app/build.gradle 添加如下行到dependencies里面: 12androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'androidTestCompile 'com.android.support.test:runner:0.5' 设置 instrumentation runner 在相同的build.gradle文件里，添加如下行到android.defaultConfig里面: 1testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" build.gradle 文件示例123456789101112131415161718192021222324252627282930313233343536apply plugin: 'com.android.application'android &#123; compileSdkVersion 23 buildToolsVersion "23.0.3" defaultConfig &#123; applicationId "com.example.shoewann.espressouiautomation" minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.4.0' compile 'com.android.support.constraint:constraint-layout:1.0.0-alpha1' testCompile 'junit:junit:4.12' // Testing-only dependencies androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2' androidTestCompile 'com.android.support.test:runner:0.5' // App's dependencies, including test androidTestCompile 'com.android.support:support-annotations:23.4.0'&#125; Espresso 基本使用方法 Espresso – 与视图（views）交互的入口，并暴露了一些视图（views）无关的API（例如回退按钮）。 ViewMatchers – 实现匹配器的一组对象。允许可以通过多次的onView方法，在层次图中找到目标视图（views）。 ViewActions – 对视图触发动作（例如点击）。 ViewAssertions – 用于插入测试关键点的一组断言，可用于判断某视图（view）的状态。 示例:123onView(withId(R.id.my_view)) // withId(R.id.my_view) is a ViewMatcher .perform(click()) // click() is a ViewAction .check(matches(isDisplayed())); // matches(isDisplayed()) is a ViewAssertion ViewMatcher : 寻找View 根据ID找View : 1withId(R.id.my_view) 根据View的文本内容找View: 1withText("my_view_text") withText 內还可以使用其他过滤字串的方法,withContentDescription、startsWith、endsWith、equalToIgnoringCase、equalToIgnoringWhiteSpace、containsString、allOf、anyOf等等,在过滤中，也可以用 hasSibling() 、is() 、instanceOf() 等等来判断条件。如： 1withText(startsWith("MY_VIEW_TEXT") ViewAction : 操作View使用 perform() 进行想要的 ViewAction，参数可带多个，常见的有: Click（）点击操作 1onView(...).perform(click()) typeText() 、clearText() 键盘开关的操作 1onView(...).perform(typeText("I'm shoewann;"),closeSoftKeyboard()) perform(clearText()) scrollTo() Scroll View 时，此 View 必须是继承 ScrollView 且 Visibilty 为 true 的控件,若为 listView 另有方法。 swiftLeft()、swiftRight() 向左右滑动 pressKey() 键盘事件操作 如:pressBack();可单独使用，或是用 EspressoKey Builder 创建 pressKey 连续顺序键盘操作。12345678EspressoKey.Builder builder = new EspressoKey.Builder();builder.withKeyCode(KeyEvent.KEYCODE_VOLUME_UP);builder.withKeyCode(KeyEvent.KEYCODE_MUTE);builder.withKeyCode(KeyEvent.KEYCODE_POWER);builder.withKeyCode(KeyEvent.KEYCODE_BACK);pressKey(builder.build()); ViewAssertion : 验证 View matches()：指定 View 为存在 doesNotExist ()：指定 View 为不存在 selectedDescendantsMatch()：指定 View 的 Parent View 存在 方法內依然都是传人 ViewMatcher 來找到指定的 View，若 Assert 失敗，则会跳出 Exception 并結束 Test。 示例:12onView(withId(R.id.test_view)) .check(matches(withText("hello espresso !!"))); 用onData处理列表view示例:有一个Spinner,当item选中后，将其值显示显示在TextView上 1.点击Spinner打开选项列表1onView(withId(R.id.spinner_simple)).perform(click()); 2.点击在item “Americano”1onData(allOf(is(instanceOf(String.class)), is("Americano"))).perform(click()); 3.验证TextView显示的是否为点击的item12onView(withId(R.id.spinnertext_simple)) .check(matches(withText(containsString("Americano")))); (espresso-cheat-sheet-2.1.0) 添加Espresso的TestRunner.1) 点击顶栏菜单Run-&gt;Edit Configurations;2) 出现如下的窗口后,点击左上角绿色的“+”,选择“Android Tests”; 3) 修改新Configuration的名字,选中App Module,输入Runner,选择“Show chooer dialog”. 点击“OK”完成! 新建测试用例类.Android Studio 在创建新项目的同时会默认的创建一个android test的测试用例类在app/androidTest/java下，你可以删除了自己创建一个新的，或者修改这个存在的测试类的类名和里面的内容。 开始编写——布局文件我在这里创建了一个登录界面，来自动测试登录效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.shoewann.espressouiautomation.MainActivity" tools:layout_editor_absoluteX="0dp" tools:layout_editor_absoluteY="81dp"&gt; &lt;EditText android:layout_width="0dp" android:layout_height="wrap_content" android:inputType="textEmailAddress" android:ems="10" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="16dp" android:id="@+id/editText" android:hint="请输入邮箱号" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toTopOf="@+id/activity_main" android:layout_marginTop="16dp" tools:layout_constraintTop_creator="1" app:layout_constraintRight_toRightOf="@+id/activity_main" android:layout_marginRight="8dp" android:layout_marginEnd="8dp" tools:layout_constraintRight_creator="1" /&gt; &lt;EditText android:layout_width="0dp" android:layout_height="wrap_content" android:inputType="numberSigned" android:ems="10" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="66dp" android:id="@+id/editText2" android:layout_margin="8dp" android:hint="请输入密码" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/editText" android:layout_marginTop="8dp" tools:layout_constraintTop_creator="1" app:layout_constraintRight_toRightOf="@+id/activity_main" android:layout_marginRight="8dp" android:layout_marginEnd="8dp" tools:layout_constraintRight_creator="1" /&gt; &lt;Button android:text="登录" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:layout_editor_absoluteX="16dp" tools:layout_editor_absoluteY="123dp" android:id="@+id/button" android:layout_margin="8dp" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="16dp" android:layout_marginStart="16dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/editText2" android:layout_marginTop="15dp" tools:layout_constraintTop_creator="1" /&gt; &lt;TextView android:text="状态：未登录" android:layout_width="wrap_content" android:layout_height="wrap_content" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="187dp" android:id="@+id/textView" app:layout_constraintLeft_toLeftOf="@+id/activity_main" android:layout_marginLeft="8dp" android:layout_marginStart="8dp" tools:layout_constraintLeft_creator="1" app:layout_constraintTop_toBottomOf="@+id/button" android:layout_marginTop="16dp" tools:layout_constraintTop_creator="1" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 开始编写——代码源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private EditText et_email,et_pwd; private Button btn_login; private TextView tv_status; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; public void initView()&#123; et_email= (EditText) findViewById(R.id.editText); et_pwd= (EditText) findViewById(R.id.editText2); btn_login=(Button) findViewById(R.id.button); tv_status=(TextView)findViewById(R.id.textView); &#125; public void initData()&#123; btn_login.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.button: String getEmail=et_email.getText().toString(); String getPwd=et_pwd.getText().toString(); if(TextUtils.isEmpty(getEmail) || TextUtils.isEmpty(getPwd))&#123; ShowLoginFailed(); return; &#125;else if (!getEmail.equals("xuwang0402@gmail.com")|| !getPwd.equals("1234567890"))&#123; ShowLoginFailed(); &#125;else &#123; ShowLoginSuccessful(); &#125; break; default: break; &#125; &#125; public void ShowLoginSuccessful()&#123; tv_status.setText("登录状态:登录成功,欢迎回来~"); &#125; public void ShowLoginFailed()&#123; tv_status.setText("登录状态:登录失败,帐号或密码不合法,请重试！"); &#125;&#125; 开始编写——测试用例1) 首先创建一个@Rule,ActivityTestRule用来指明被测试的Activity;2) 测试用例的方法都是@Test的Annotation注解的,方法名字可以随意. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import android.support.test.filters.MediumTest;import android.support.test.rule.ActivityTestRule;import android.support.test.runner.AndroidJUnit4;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import static android.support.test.espresso.Espresso.onView;import static android.support.test.espresso.action.ViewActions.clearText;import static android.support.test.espresso.action.ViewActions.click;import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard;import static android.support.test.espresso.action.ViewActions.typeText;import static android.support.test.espresso.assertion.ViewAssertions.matches;import static android.support.test.espresso.matcher.ViewMatchers.withId;import static android.support.test.espresso.matcher.ViewMatchers.withText;/** * Instrumentation test, which will execute on an Android device. * * @see &lt;a href="http://d.android.com/tools/testing"&gt;Testing documentation&lt;/a&gt; */@MediumTest@RunWith(AndroidJUnit4.class)public class MainActivityUITest &#123; private String testEmail_correct,testPwd_correct,tv_status_incorrect; private String testEmail_incorrect,testPwd_incorrect,tv_status_correct; @Rule public ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;(MainActivity.class); @Before public void initLogInAccountInfo()&#123; //incorrect testEmail_incorrect="zhangsan@gmail.com"; testPwd_incorrect="123456"; tv_status_incorrect="登录状态:登录失败,帐号或密码不合法,请重试！"; //correct testEmail_correct="xuwang0402@gmail.com"; testPwd_correct="1234567890"; tv_status_correct="登录状态:登录成功,欢迎回来~"; &#125; @Test public void testLogInMethod()&#123; //incorrect onView(withId(R.id.editText)).perform(typeText(testEmail_incorrect), closeSoftKeyboard()); onView(withId(R.id.editText2)).perform(typeText(testPwd_incorrect), closeSoftKeyboard()); onView(withId(R.id.button)).perform(click()); onView(withId(R.id.textView)).check(matches(withText(tv_status_incorrect))); //clearEditText onView(withId(R.id.editText)).perform(clearText()); onView(withId(R.id.editText2)).perform(clearText()); //correct onView(withId(R.id.editText)).perform(typeText(testEmail_correct), closeSoftKeyboard()); onView(withId(R.id.editText2)).perform(typeText(testPwd_correct), closeSoftKeyboard()); onView(withId(R.id.button)).perform(click()); onView(withId(R.id.textView)).check(matches(withText(tv_status_correct))); &#125;&#125; 在这里我用了一个正确的帐号和一个错误的帐号来自动化模拟登录效果，系统会先自动输入错误的邮箱号码和密码，然后自动点击登录,然后自动获取到显示文本上的内容判断是否和我预期定义的一致，然后自动清除账号和密码输入框，重新自动输入正确的帐号密码，然后自动点击登录,然后自动获取到显示文本上的内容判断是否和我预期定义的一致，达到自动化测试的效果。 Espress推荐写测试用例的时候使用static import来简化代码.在Android Studio中,static import的快捷键是,当你输入了”onView”,然后按键盘的Alt+Enter会出现一个菜单选static import那个就OK了的! 运行测试用例,查看运行结果.展开下拉列表，选择我们刚刚创建的测试类的对应模块的名字 “appTest” 可以看到所有测试已通过]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Studio-2-2-预览版-——-新的UI设计器和约束布局]]></title>
      <url>%2F2016%2F05%2F20%2FAndroid-Studio-2-2-%E9%A2%84%E8%A7%88%E7%89%88-%E2%80%94%E2%80%94-%E6%96%B0%E7%9A%84UI%E8%AE%BE%E8%AE%A1%E5%99%A8%E5%92%8C%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[原文来自：ByJamal Eason, Product Manager, Android ———— Android Studio 2.2 Preview - New UI Designer &amp; Constraint Layout 在这周的2016 Google I/O大会上我们已经启动了Android Studio 2.2 预览版.这次公布了一个重大的升级，就是我们重点关注于打造一个快速和高效的Android集成开发环境（IDE）。同步了Android开发平台，Android Studio允许你利用最新版本的Android API和新特性去开发。从3年前的Google I/O上启动了Android Studio，针对于每个人想要什么样的功能特性，我们收到了很棒的反馈。如今在Google Play上排在前面的125个应用和游戏，92%的开发者，数百万的开发者，都是使用的Android Studio。我们要继续为Android加强功能特性，并将继续让你更有效率，更富有成效的开发。 Android Studio 2.2预览版包括了一个伴随着范围开发的组合新特性, 对于你的应用程序利用全新的方法，分类从用户界面设计到构建再到调试，对于预览版本包括了以下的一些新功能特性的分类： 设计 布局编辑器：一个全新的用户界面设计器，能帮助你在你的应用程序里直观的设计布局。功能特性像蓝图模式和全新的属性配置面板允许你更加快速的编辑布局和小部件. 约束布局：一个全新的强大灵活的Android布局允许你展现出没有嵌套多个布局的复杂的用户界面。 审查布局：一个在你的Android模拟器或者真机设备上运行你的应用程序布局的调试快照，审查视图结构和相应的代码属性。 开发 Firebase 插件：通过Firebase提供的资源套装组合并内置在Android Studdio里面，添加像Analytics分析服务、认证、通知和广告仅仅只需要点击几下。 增强的代码分析：Android Studio 检查你的Android应用程序代码质量，这里除了260个Android Lint和代码检查，还包括公布的为了Java 8语言全新代码的检查，使用和更多的跨文件分析的新的检查基础的设施。 浏览器示例：引用Android 示例代码如今是很便利的了，内置了代码编辑窗口，在谷歌安卓代码示例上去寻找你应用程序需要的代码片段，帮助你在开发你的应用程序中有一个好的跨越。 提升对C++的支持：Android Studio 2.2提高了C++开发的编辑、构建、调试现有Android项目的能力,利用的是ndk-build或者CMake，而不是Gradle。另外，现有的lldb C++ 调试器是如今最好的项目类型自动识别器，在java语言里察觉C++,让你使用一个单一的调试器进程就可以连同java和C++语言运行时一起检查 Intellij 2016.1：Android Studio 2.2 包括了JetBrains的Intellij平台从底层最新版本的所有东西。 构建 Jack编译器的改进：这里使用全的Jack编译器，Android Studio 2.2添加了对注释处理的支持，以及增量编译以降低编译时间。 合并清单的查看器：通过你的项目构建变种，利用你的应用程序依赖来诊断你的AndroidManifest.xml合并。 测试 Espresso 测试记录：作为一个普通人来使用你的应用程序只是简单的使用Espresso 用户界面测试来记录。作为你点击了你的应用程序用户界面，然后为你生成可以重复使用的和可以编辑的测试代码，你可以在本地运行生成来测试，在你连续不断的集成环境中，或者在Firebase 测试实验室 APK分析器：钻进你的APK应用重新中去帮助你降低APK应用程序的大小，调试64K方法的限制问题，查看Dex文件或者其他更多的。 更加深入地了解了新功能设计布局编辑器Android Studio 2.2的功能特性——新的用户界面设计器，有很多的改进，但是一些亮点包括： 从设计图面或者组件树视图拖放控件到你的应用程序 对于检查你的布局的间距和排版，设计面有了一个蓝图模式 属性配置面板现在能够显示属性配置组，对于快速编辑控件利用一个完整的配置表点击即可 UI生成器能够编辑菜单和系统偏好文件. (Android Studio 2.2 Preview 里新的布局编辑器) (新布局编辑器里的菜单编辑) 约束布局这种全新的布局对于你的应用来说是一个灵活的布局管理器，它允许你动态创建多个无嵌套的用户界面。它作为一个支持库分布在Android Studio中, 且支持API 9向后兼容。 乍一看，约束有点内类似于RelativeLayout. 然后，约束布局被设计在Studio中使用，它能够有效的表现出你的应用程序的设计，因此依靠较少的去使用像LinearLayout, FrameLayout, TableLayout,或者GridLayout的布局。最后，它还内置了自动约束引擎。你可以根据你直接的偏好去随时设计你的用户界面,让Android Studio努力工作起来 为了帮助你开始，在Android Studio 2.2 预览版中，新建项目向导的时候，现在内置模板能生成一个约束布局。或者，你可以在一个新的布局编辑器里右键任意布局，然后选择Convert to ConstraintLayout 选项。 这是一个早期预览版的UI设计器和约束布局，我们将加大速度在即将发布的版本中增加附件的东西，在Android Studio 工具站点查看更多。 (约束布局) 审查布局对于一个新的和已经存在的布局，很多时间你或许想要调试你的应用程序用户界面，以确定是否按照预期的布局呈现出来.利用新的布局审查工具，你能够深入到你的应用程序的视图层级下，分析屏幕上UI的每一个组件的属性。 (开始一个布局的审查) (布局审查) 开发Firebase 插件firebase是一个开发者服务新套装，能够帮助你开发高质量的应用程序 ，让你的用户数据库增长，并且赚更多的钱。在Android Studio里面，你利用新的助理窗口添加了Firebase到一个全新的或者已经存在的Android应用程序中。对于访问Firebase功能特征在点击菜单Tools然后选择Firebase.你会希望先设置好全新的Firebase分析,为你探索其他Firebase服务像Firebase云消息或者Firebase崩溃报告添加到你的应用重新作为基础。学习更多有关Android Studio整合Firebase的信息看这里 (为Android Studio 整合的Firebase插件) 代码示例浏览器除了导入Android Studio 是示例代码，代码示例浏览器在Androdi Studio 2.2 Preview里面是一个菜单选项，允许你依靠高质量，Google 提供的Android 代码样本示例中高亮的代码片段添加到你的项目中去。对于使用这个功能特性,高亮的变量、类型和方法在你的代码中，然后右键显示一个菜单去查找示例代码。 (代码样本浏览器) 构建CMake 和 NDK-Build对于那写使用过NDK的，现在Android Studio通过现有的Gradle支持CMake和NDK-Build Android应用程序项目在你存在的构建文件，一旦你添加了你的CMake或者NDK-Build项目到你的Gradle,Android Studio将会自动的打开你的Android相关代码在Studio里面进行编辑和调试。 对于CMake用户，仅仅是在你的Gradle文件的externalNativeBuild部分添加你的CMList.txt文件路径: (在Android Studio中的CMake) 对于NDK-Build用户，仅仅是在你的Gradle文件externalNativeBuild部分添加你的*.mk文件路径: (在Android Studio中的CMake) Jack 工具的增强新的Jack编译器编译你的Java语言源文件到Android dex字节码.Jack 编译器允许一些Java 8 语言的特性，像lanmbdas,在Android所有版本中都能够使用.此版本增加了增量构建和完全支持注释处理，所以你能够使用Java 8 语言特性到你已经存在的项目资源中 如下在你的build.gradle文件中使用Jack增量编译: (启用Jack增量编译选项) Jack 将会自动应用注解处理器在类路径中，要使用在编译时注释处理器，而无需在APK捆绑它，利用全新的注解处理器依赖范围: (启用Jack注解处理器) Manifest 合并查看器弄清楚你的项目依赖基于编译类型等是如何合入AndroidManifest，现在利用Android Studio就很简单了，导航到你AndroidManifest.xml，然后点击合并后的新的清单底部标签，探索你AndroidManifest上的解析每一个节点如何与不同项目依赖 (清单合并查看器) 测试Espresso 测试记录器有的时候写一个用户界面测试是很乏味的，利用Espresso UI 测试记录功能，创建测试现在和使用你的应用程序一样简单了，Android Studio 将会捕获你所有的UI交互，并将其转换为一个完全可以重用的Espresso测试，你可以在本地或者甚至在Firebase 测试实验室上去运行它们，要使用记录器，转到Run菜单，选择Record Espresso Test (Espresso 测试记录器) APK 分析器新的APK分析器可以帮助您了解您的APK内容、不同组件的大小。你也可以用它来避免你的Dex文件64K参考方法的限制的问题，诊断ProGuard的配置问题，鉴于合并AndroidManifest.xml文件，并检查编译资源文件（resources.arsc）。这可以帮助你减少你的APK大小，并确保您的APK包含的东西，正是你期待的事情。 该APK分析器显示你的原始文件的大小以及在下载你的APK后各种组成部分的大小。预计当用户下载存放APK在Google Play服务器上的大小，这些信息可以帮助你优先考虑哪些地方需要集中去减少占用量。 要使用这项新功能，单击Build菜单上，选择分析Analyze APK…然后，选择要分析的APK。 (APK分析器) Java-察觉 C++ 调试器当你运行在N或者更高的目标版本上调试C++代码，你现在可以使用一个单一的调试器，Java语言能够感知lldb实例.这个调试器继续大大的支持lldb功能，如快速的步骤和内存观测点，也允许你停止对Java语言的断点，并查看你的Java语言内存上的内容 自动调试选择Android Studio 现在能够使用 “自动” 调试器调试应用，这里将会自动的启动相应的调试器,如果启用了其他C++项目混合调试器，Java语言是能够感知C++调试器的。 (为C++启用自动调试器) 接下来做什么下载如果你是用的之前上一个版本的Android Studio，你可以在菜单导航栏Canary通道使用检查更新(Help–&gt;Check for Update(Windows/Linux)，Android Studio–&gt;Check for Updates(OSX))，这个升级将会下载一个全新的版本，没有增量更新到你已经存在的Android Studio中，你也可以从Canary发布站点下载Android Studio 2.2 Preview 对于Android Studio 2.2 Preview，我们建议你在运行新的Canary版本的同时，也运行一个Stable稳定版本的Android Studio ,到工具站点检出如何在同一时间运行两个版本的Android Studio 我们很欣赏你们反馈的任何你们遇到问题、觉得看到喜欢的新特性，联系我们 —— Android Studio 开发团队—— 我们在Google+ 或者 Twitter上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO-2016-Android-更新了什么？]]></title>
      <url>%2F2016%2F05%2F19%2FIO-2016-Android-%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[原文来自：Google Android developer Blog —— What’s new in Android: the N-Release, Virtual Reality, Android Studio 2.2 and more 在过去的一年中,在Google Play上像你一样通过安装开发者构建的应用程序的Android用户，全球安装量已经超过了650亿。在Android排在前面的应用帮助里开发者继续去构建卓越的经历。今天在Google I/O上，我们宣布了一系列新的东西，我们在这些平台上去做，包括Android N下一个版本的开发者预览版，一个Android系统集成虚拟现实的延伸，一个Android Studio的更新升级 以及更多！ Android N : 性能、效率和安全性利用Android N,我们想实现一个全新级别的Android产品挑战，因此对于平台我们将搬出一些十分深度的技术，重写和重新设计一些系统如何工作的基本方面，对于Android N ,我们主要集中在三大关键主题上:性能、效率以及安全.第一个Android开发者预览版包括了一个全新的品牌JIT编译器，对于提高软件性能、使应用程序安装的更加快，并且占用更少的存储空间。第二个Android N 的开发者预览版包括了Vulkan,一个全新的3D渲染API帮助游戏开发者在手持设备上传递高性能图像。这两次的预览版也给Android带来了提高效率有用的东西，包括了多窗口支持和直接回复 Android N也添加了一些新的特性去帮助用户保持最快和更安全，通过如何在Chromebooks上应用更新的方法受到了启发，我们采用无缝升级，因此新的Android设备在N上面构建将在后台执行安装系统升级。这将意味着下一个时间用户开机他们的设备，新的设备能够自动无缝切换到新的更新后的系统映像。 今天公布的Android N 预览版3是我们第一个beta测试版本,在你的常用手机或者平板上可用来进行测试，你可以选择到Android测试程序在android.com/beta，然后在你的Nexus6,9,5X,6P,Nexus Player,Pixel C,和Android One（一般的移动4G）.通过邀请更多的人去尝试这个公布的测试，开发者能够期望看到你的应用程序在Android N上的用法去提升。如果你有一个Android应用程序,你应该去测试，看它在Android N上是如何工作的，并且也能从用户那儿得到反馈信息。 Android中的虚拟现实模式Android 为了当今的多屏世界而构建；事实上，Android工作在你的手持设备，你的平板，在你的手腕上看，它甚至工作在你的汽车里和你的市内。同时帮助你在所有设备中每个之间个无缝移动，当我们展望下一部是什么的时候，我们相信你的手机能够成为很厉害看世界和新虚拟内容体验，更逼真的方式的新道路，但是，直到此时，高品质的移动VR贯穿整个Android生态系统是不可能的。那是因为我们将在Android N的任务中去完成所有的级别任务——从操作系统如何读取传感器数据，如何发送像素去显示——利用Android中的VR虚拟现实模式，提供高质量的移动VR虚拟现实体验，使它特别内置。这儿有专门为开发人员性能增强设计，包括一个单缓冲渲染和访问一个独有的CPU核心的VR虚拟显示应用程序，在你的应用程序里面，你能利用流畅的头部跟踪和立体声通知进行工作对于虚拟现实。最重要的是，Android N 提供了一个非常低的图形延迟；事实上，在Nexus 6P上运行开发者预览版3光子运动延迟小于20毫秒，建立必要的速度沉浸，然用户能够感觉到他们其实在另外一个地方，我们将在明天上午9点开始,从Google IO 直播的谷歌虚拟现实专题里升级覆盖所有全新的VR虚拟现实。 Android瞬间应用程序:真实的应用程序，没有安装我们想让用户发现和使用的应用程序变得更加的简单，你的应用程序轻轻一按会怎样？如果用户没有所有都安装呢？今天，我们介绍Android瞬间应用程序作为我们努力发展方式的一部分，我们想想应用，是否有人发现从搜索，社交媒体，短信或其他深层链接您的应用程序，他们将能够体验到快速和强大的原生Android应用程序，而无需停下来先安装您的应用程序或重新认证。最好的，Android瞬间应用程序它利用Google服务并能兼容运行在果冻豆（Android 4.1+）或者更高的所有Android 设备上。Android瞬间应用程序功能是升级到您现有的Andr​​oid应用程序，而不是一个新的，独立的应用程序;你可以早些登录请求访问这篇文档 Android可穿戴设备2.0：UI改变和应用重新独立今天早上在google IO大会上，我们也公布了Android可穿戴设备上自从启动了两年以来的大多数重大更新Android 可穿戴设备2.0，根据我们已经从用户和开发人员了解到，我们正在不断发展的平台，提高关键腕表体验：表盘、信息和健康，我们也制作了大量的UI改变和升级我们的设计指南，让你的应用程序更加一致、直观，美观。利用可穿戴设备2.0，应用程序可以是独立的，并且具有通过蓝牙，Wi-Fi或蜂窝连接直接网络接入到云中。由于您的应用程序将不必依赖于数据层的API，它可以继续提供，即使配对的电话是远或关闭的全部功能。你可以在这里在今天的预览版阅读所有可用的新特性 Android Studio 2.2 预览版: 全新的布局设计，布局约束，以及更多 速度: 全新的布局设计和布局约束，即时测试记录，编译速度更快 能干：Apk应用重新分析、布局审查，扩大Android的代码分析和IntelliJ 2016.1 平台支持：增强Jack编译/Java 8 的支持,利用CMake和NDK-Build扩大C++的支持,Firebase支持和无障碍的支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android浅谈任务和返回栈]]></title>
      <url>%2F2016%2F05%2F17%2FAndroid%E6%B5%85%E8%B0%88%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E6%A0%88%2F</url>
      <content type="text"><![CDATA[(…..咳咳, 别点了，上面这个只是一个截图而已. @_@! ) 原文来自：Google Android developer by lan Lake —— Tasks and the Back Stack 当我们点击了launcher桌面上App应用程序实际上发生了什么呢？如果你说“我的应用程序启动起来了”，你在技术上是正确的，也是在所有回答类别中最佳的一个.如果我们在深入一点，我们利用返回这件小事情去看看，它对我们理解什么是任务以及它是如何去交互的会有帮助的 任务一个任务是围绕着一个活动栈元数据和信息的集合（你可以查看RecentTaskInfo类获取更准确的数据）。 所以当你点击了launcher桌面上你的App应用程序，系统其实会开始去上一个已经存在的任务（通过Intent意图和Activity活动来指向确定) 去恢复—— 然你回到你该回到的地方.如果任务中没有存在可以被发现，然后利用最新启动的Activity作为基类Activity，一个新的任务就在任务的返回栈里被创建了。 返回栈你或许会想象，返回键一个任务的返回栈是捆绑在一起的，但是它是双向的，当你开始利用startActivity()启动一个新的activity,将会（默认情况下）推送出一个新的activity在你的任务之上，原因是上一个Activity 已经被暂停了（如果这个新的activity完全掩盖了上一个activity，就被停止了）。 当操作返回键时（默认情况下）然后会‘抛出’任务，在最顶端的activity将会调用finish(),销毁它并且从返回栈中移除，同时带你返回上一个activity。重复这样操作直到在返回栈中不会留下任何东西了，你也就将回到launcher桌面上了。 返回栈和Fragments返回栈不是仅仅用于activity上：它也应用于fragments。当你提供一个fragment transaction从你的用户界面去添加，替换，或者移除一个fragment，你能够使用addToBackStack()去有效添加FragmentTransaction到你的返回栈 当你使用这种方式，返回键被点击中，FragmentTransaction 将会被反向（一个添加的fragment被移除，一个替换的fragment被还原，或者一个被移除掉的fragment被重新添加）。每一个事务被添加到返回栈是被反向翻转的，直到默认的activity被finish结束的那个时候，它们所有才会被移除，再次放进来将会重复表现。 返回不是唯一的导航键当然，在一个现代化的Android设备里（我们不去过多的讨论有关menu button相关的东西）返回键不是唯一的导航键。 home 键可能是最简单的，它是单焦点：它放置当前任务到后台，然后带着你回到你的launcher桌面上。 笔记:移动你的任务到后台，不会杀死你的任务（虽然最顶端的activity肯定被暂停+被停止）: 它将一直存活直到Process(进程)被杀死。在‘Who lives and who dies ?(谁活着，谁灭亡？)这篇博客优先学习更多有关进程和什么时候你的app应用会被杀死。 overview 键(最近任务)，带领你，你或许会想象，对于Overview screen,这是在Android世界里的’应用程序切换器’—— 在这儿你将会看到你最近的任务，也能够选择其中的一个带它返回到前台。 ##好了，就是它们这些了，没有更多可以看的了梳理一下，startActivity()或addToBackStack()返回键默认的特性。这儿没有什么特别的，但没有任何混淆 —— 这些对称，一致的行为作为默认。在多数情况下，你应该使用这些默认的特性 在你直接运行和复写onBackPressd()之前，这儿有一些特殊的情况你或许要去是考虑一下： 防止返回键疲劳过度当然，当你需要按10+次走出你在哪里，返回按钮会失去了一些光泽，另一种情况，当你启动的是当前同一个activity，这是很容易避免的， 创建一个任务多个复制相同Activity,（无论是从内存压力还是返回键疲劳过度都一起减少了）你的Activity能够在AndroidManifest使用launchMode=”singleTop”或者你能够在你的Intent意图里添加Intent.FLAG_ACTIVITY_SINGLE_TOP 在顶部返回栈防止同一个activity拷贝多个副本，利用new Intent 和任意的extras你将会在onNewIntent()中得到一个回调。 笔记:在读onNewIntent()文档时小心：getIntent()将一直返回原始的Intent除非你使用setIntent()去重写它 返回栈和通知如果你将在你的应用里构建一个通知指定一个Activity，这里有一种情况要避免:点击返回键直接回到launcher桌面上。当你利用一个基本的activity提供一个PendingIntent开启一个新的任务会出现这种情况，除非你的通知是打开你的启动activity,这不是你想要的。如果它们作为导航到应用本身重新的那一部分，用户应该是明确目标地点的，你的通知仅仅是保存了它们的中间步骤。 对于某些事情是如此的重要，有一个类它将会为你完成所有的任务这将是非常好的。进入TaskStackBuilder: 一个处理标志和返回栈的特殊类，对于你对于这种情况： // Construct the Intent you want to end up at Intent detailActivity = new Intent(this, DetailActivity.this); // Construct the PendingIntent for your Notification TaskStackBuilder stackBuilder = TaskStackBuilder.create(this); // This uses android:parentActivityName and // android.support.PARENT_ACTIVITY meta-data by default stackBuilder.addNextIntentWithParentStack(detailActivity); PendingIntent pendingIntent = stackBuilder .getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT); 你将在使用addNextIntentWithParentStack()方法时注意 —— 这个方法在正常Intent意图，你将创建了一个PendingIntent去构建一个完整的任务栈刚好通过的捷径。虽然它有一个要求：每一个activity需要有一个它的父activity定义在Androidmanifest(从这篇文档中看示例代码)。 如果在你情况下默认不工作，你不需要抛出TaskStackBuilder:editIntentAt()允许你回收一个特殊的Intent意图并设置action动作，设置data URL数据地址，或者add extras传一个值。如果你需要甚至更多的定制，你可以放弃使用*ParentStack()方法完全直接使用 addNextIntent()添加确切你需要的Intent到你的具体情况 笔记:如上所述在文档里,对于其他类型的activity你或许从一个特殊的notification通知(i.e，没有在你正常的应用重新流程下的一个通知)去启动。这个或许是一个例子，环聊的（Hangout’s）直接回复像一个activity在Android N之前。这些acitivities是通常半透明 —— 你能看到其他的app应用程序在你的activity下面 —— 同时一般没有任何返回栈合成或者新的任务和它们关联。 任务和返回栈，一起工作记住这个部分已经被预测很重要，如果将是使用你的返回栈乱搞，请确保测试非常彻底，以确保最佳的用户体验。 翻译有限，不足之处，欢迎指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Google官方Android开源库--FlexboxLayout]]></title>
      <url>%2F2016%2F05%2F16%2FGoogle%E5%AE%98%E6%96%B9Android%E5%BC%80%E6%BA%90%E5%BA%93-FlexboxLayout%2F</url>
      <content type="text"><![CDATA[原文来自： Flexbox-layout 什么是Flexbox？Flexbox 布局模型宗旨是对于在一个flex容器平铺出flex项提供更多高效的方法，即使flex项的大小未知.因此，它提供了更有效的方法,利用已存在的布局去实现响应式用户界面. 布局模型 安装Gradle依赖1234dependencies &#123; compile 'com.google.android:flexbox:0.1.2'&#125; 用法FlexboxLayout像LinearLayout和RelativeLayout一样继承了ViewGroup，你可以在一个XML中像这样指定属性: 123456789101112131415161718192021222324252627282930&lt;com.google.android.flexbox.FlexboxLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" app:flexWrap="wrap" app:alignItems="stretch" app:alignContent="stretch" &gt; &lt;TextView android:id="@+id/textview1" android:layout_width="120dp" android:layout_height="80dp" app:layout_flexBasisPercent="50%" /&gt; &lt;TextView android:id="@+id/textview2" android:layout_width="80dp" android:layout_height="80dp" app:layout_alignSelf="center" /&gt; &lt;TextView android:id="@+id/textview3" android:layout_width="160dp" android:layout_height="80dp" app:layout_alignSelf="flex_end" /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 或者在代码中，像这样： FlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout); flexboxLayout.setFlexDirection(FlexboxLayout.FLEX_DIRECTION_COLUMN); View view = flexboxLayout.getChildAt(0); FlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams(); lp.order = -1; lp.flexGrow = 2; view.setLayoutParams(lp); 支持的属性对于一个FlexboxLayout，你能指定以下的属性： 1.flexDirection 子项的方向是摆放在Flexbox布局里面的，它决定里主轴线的方向（和十字交叉轴，垂直于主轴线），可能的值是： row (default) 主轴为水平方向，起点在左端 row_reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上沿 column_reverse 主轴为垂直方向，起点在下沿。 2.flexWrap 这个属性控制着flex容器是单行还是多行，方向是十字交叉轴可能的值是： nowrap (default) 不换行 wrap 按正常方向换行 wrap_reverse 按反方向换行 3.justifyContent 这个属性控制着主轴线的边缘对齐方式，可能的值是： flex_start (default) 左对齐 flex_end 右对齐 center 居中 space_between 两端对齐 space_around 每个子项两侧间的间距离相等 4.alignItems 这个属性控制着十字轴的边缘对齐方式，可能的值是： stretch (default) 如果子项没有设置高度或者设为auto，将占满整个容器的高度 flex_start 交叉轴的起点中对齐 flex_end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对其 5.alignContent 这个属性控制着flex行和flex容器的边缘对齐方式，可能的值是： stretch (default) 轴线占满整个交叉轴 flex_start 与交叉轴的起点对齐 flex_end 与交叉轴的终点对齐 center 与交叉轴的终点对齐 space_between 与交叉轴两端对齐，轴线之间的间隔平均分配 space_around 每根轴线两侧的间隔相等 你也可以在FlexboxLayout中指定以下的属性： 1.layout_order 这个属性是能够改变子视图如何平铺的顺序. 默认你情况下，子视图显示和平铺顺序在布局XML文件中呈现的是相同的，如果不是指定情况下，1是它默认设置的值 2.layout_flexGrow 这个属性定义项目的放大比例，即如果存在剩余空间，也不放大，0是它默认设置的值 3.layout_flexShrink 这个属性定义了项目的缩小比例，即如果空间不足，该项目将缩小，0是它默认设置的值负值对该属性无效。 4.layout_alignSelf 这个属性确定（垂直于主轴线）沿着横轴的对齐。在同一方向上的对准可由父视图的alignItems确定，但是如果这是设置为auto以外的值，对于这个子视图来说十字轴对准是要被重写。可能的值有： auto (default) (自动) flex_start （与交叉轴的起点对齐） flex_end（与交叉轴的终点对齐） center（与交叉轴的中点对齐） baseline（与第一行文字的基线对齐） stretch （如果子项没有设置高度或者设为auto，将占满整个容器的高度） 5.layout_flexBasisPercent 在一个分数格式中初始化flex项的长度，相对于父视图.该子视图的初始大小主要是试图扩大作为对父视图主要尺寸为指定的分数.如果这个值设置了，通过layout_width (或者 layout_height)这个属性计算值重写来指定长度.这个属性仅仅当它的父视图长度定义了(MeasureSpec 模式是MeasureSpec.EXACTLY）时才有效.默认值是-1，意味着没有设置 跟传统已知的CSS的区别 没有flex-flow属性 没有flex属性 layout_flexBasisPercent代替 flexBasis 最小宽度和最小高度不能被指定]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的进程与线程]]></title>
      <url>%2F2016%2F05%2F15%2FAndroid%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[节选来自：Android 官方文档- Process And Thread 当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。 本文档介绍进程和线程在 Android 应用中的工作方式。 进程（Process）默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。 各类组件元素的清单文件条目— activity 、service、receiver和provider—均支持android:process属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。 此外，application 元素还支持 android:process 属性，以设置适用于所有组件的默认值。 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。 决定终止哪个进程时，Android系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。 进程生命周期（Process Lifecycle）Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。 重要性层次结构一共有 5级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）： 1.前台进程 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 托管用户正在交互的 Activity（已调用 Activity 的 onResume()) 方法） 托管某个 Service，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service（服务已调用 startForeground())） 托管正执行一个生命周期回调的 Service（onCreate())、onStart()) 或 onDestroy())） 托管正执行其 onReceive()) 方法的 BroadcastReceiver 通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。 2.可见进程 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause()) 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况 托管绑定到可见（或前台）Activity 的 Service 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 3.服务进程 正在运行已使用 startService()) 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 4.后台进程 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop()) 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅Activity文档。 5.空进程 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 根据进程中当前活动组件的重要程度，Android会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见Activity，则会将此进程评定为可见进程，而不是服务进程。 此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。 由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。 线程 （Thread） 应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小工具，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。 系统绝对不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI线程中实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown()) 或生命周期回调方法）始终在进程的 UI 线程中运行。 例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小工具，而小工具反过来又设置其按下状态，并将无效请求发布到事件队列中。UI 线程从队列中取消该请求并通知小工具应该重绘自身。 在应用执行繁重的任务以响应用户交互时，除非正确实施应用，否则这种单线程模式可能会导致性能低下。 特别地，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。一旦线程被阻塞，将无法分派任何事件，包括绘图事件。从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。 此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。因此，Android 的单线程模式必须遵守两条规则： 1. 不要阻塞 UI 线程 2. 不要在 UI 线程之外访问 Android UI 工具包 工作线程 （Worker Thread）根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。 例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中： 12345678910111213public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; Bitmap b = loadImageFromNetwork("http://example.com/image.png"); mImageView.setImageBitmap(b); &#125; &#125;).start();&#125; 乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：不要在 UI 线程之外访问 Android UI 工具包—此示例从工作线程（而不是 UI 线程）修改了 ImageView。这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。 为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程。以下列出了几种有用的方法： Activity.runOnUiThread(Runnable)) View.post(Runnable)) View.postDelayed(Runnable, long))例如，您可以通过使用 View.post(Runnable)) 方法修复上述代码： 1234567891011121314151617181920212223public void onClick(View v) &#123; new Thread(new Runnable() &#123; public void run() &#123; final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png"); mImageView.post(new Runnable() &#123; public void run() &#123; mImageView.setImageBitmap(bitmap); &#125; &#125;); &#125; &#125;).start();&#125; 现在，上述实现属于线程安全型：在单独的线程中完成网络操作，而在 UI 线程中操纵 ImageView。 但是，随着操作日趋复杂，这类代码也会变得复杂且难以维护。 要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息。当然，最好的解决方案或许是扩展 AsyncTask类，此类简化了与 UI 进行交互所需执行的工作线程任务。 使用 AsyncTask AsyncTask 允许对用户界面执行异步操作。它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。 要使用它，必须创建 AsyncTask 子类并实现 doInBackground()) 回调方法，该方法将在后台线程池中运行。要更新 UI，必须实现 onPostExecute()) 以传递 doInBackground() 返回的结果并在 UI 线程中运行，这样，您即可安全更新 UI。稍后，您可以通过从 UI 线程调用 execute()) 来运行任务。 例如，您可以通过以下方式使用 AsyncTask 来实现上述示例： 1234567891011121314151617181920212223242526public void onClick(View v) &#123; new DownloadImageTask().execute("http://example.com/image.png");&#125;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; &#123; /** The system calls this to perform work in a worker thread and * delivers it the parameters given to AsyncTask.execute() */ protected Bitmap doInBackground(String... urls) &#123; return loadImageFromNetwork(urls[0]); &#125; /** The system calls this to perform work in the UI thread and delivers * the result from doInBackground() */ protected void onPostExecute(Bitmap result) &#123; mImageView.setImageBitmap(result); &#125;&#125; 现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。 下面简要概述了 AsyncTask 的工作方法，但要全面了解如何使用此类，您应阅读 AsyncTask 参考文档： 可以使用泛型指定参数类型、进度值和任务最终值 方法 doInBackground()) 会在工作线程上自动执行 onPreExecute())、onPostExecute()) 和 onProgressUpdate()) 均在 UI 线程中调用 doInBackground())返回的值将发送到 onPostExecute()) 您可以随时在 doInBackground()) 中调用publishProgress())，以在 UI 线程中执行 onProgressUpdate()) 您可以随时取消任何线程中的任务 注意：使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。 要了解如何在这种重启情况下坚持执行任务，以及如何在 Activity 被销毁时正确地取消任务，请参阅书架示例应用的源代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Dex In Process 使Android Studio 编译更快]]></title>
      <url>%2F2016%2F05%2F13%2F%E5%88%A9%E7%94%A8Dex-In-Process-%E4%BD%BFAndroid-Studio-%E7%BC%96%E8%AF%91%E6%9B%B4%E5%BF%AB%2F</url>
      <content type="text"><![CDATA[(…..咳咳, 别点了，上面这个只是一个截图而已. @_@! ) Reto Meier - Faster Android Studio Builds with Dex In Process Android Studio 2.1 开启了一个新的特性： Dex In Process, 它能极大地提高全面清理的速度构建以及改善Instant Run(瞬间运行)的性能 要使用Dex In Process，你需要修改你的gradle.properties文件并且通过增加分配的内存量1GB到Gradle Daemon 虚拟机，对于一个最低额度为2GB的,使用org.gradle.jvmargs配置： 1org.gradle.jvmargs=-Xmx2048m 对于 Gradle Daemon 虚拟机内存 默认分配1GB —— 这样的情况不足以支持起dexInProcess，因此你将需要设置至少2GB才能利用它 Dex in process 通过运行多个DEX 进程运行在一个单一的虚拟机中共享着Gradle，这也是为什么你需要分配额外的内存才能使用它—— 内存将会被共享给Gradle和多个DEX进程 如果你将要增加javaMaxHeapSize到你module级别的build.gradle文件中，超过默认1GB，你需要增加相应的内存分配到Gradle Daemon 当默认情况下，有足够的内存分配Dex in process 是可用的，提高总体编译性能，同时移除启动多个并行虚拟机开销的实例。其结果就是在总体耗时、包括Instant Run、增量和全编都起到了显著改善 最佳值的变化依赖于不同的硬件设备，因此升级你的Android Studio到2.1 利用你的jvmargs值试验一下，看看什么才是最适合你的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Notification 通知样式总结]]></title>
      <url>%2F2016%2F05%2F12%2FAndroid-Notification-%E9%80%9A%E7%9F%A5%E6%A0%B7%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Notification 通知系统可让用户随时了解应用中的相关和即时事件，例如来自好友的新聊天信息或日历事件。可将通知视作新闻频道，在重要的事件发生时提醒用户注意，或者当作日志，在用户未注意时记录事件—可在用户的所有 Android 设备上按需同步。随着系统版本的更新，通知栏的风格种类得到扩展，从2.x、4.x、5.x、6.x，以至于最新版本的7.x(Android N)都有相当大的变化，那么现在来总结一下在Android 5.x（Lollipop）- Android 6.x(Mashmallow)上的通知栏样式，对于Android N 上的通知栏风格，我们后面在谈。 12345public static classNotification.Builderextends Objectjava.lang.Object ↳ android.app.Notification.Builder 在项目初始化的时候会，创建好通知栏管理对象—— NotificationManager 1NotificationManager manger = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); NormalStyle12345678910111213141516171819202122232425//为了版本兼容 选择V7包下的NotificationCompat进行构造NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setTicker 在5.0以上不显示Ticker属性信息builder.setTicker("状态栏显示的提示");//setContentTitle 通知栏通知的标题builder.setContentTitle("内容标题");//setContentText 通知栏通知的详细内容builder.setContentText("内容文本信息");//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//小图标//创建一个意图Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);//setContentIntent 将意图设置到通知上builder.setContentIntent(pIntent);//通知默认的声音 震动 呼吸灯builder.setDefaults(NotificationCompat.DEFAULT_ALL);//构建通知Notification notification = builder.build();//将构建好的通知添加到通知管理器中，执行通知manger.notify(0, notification); DownloadStyle123456789101112131415161718192021222324252627282930313233//为了版本兼容 选择V7包下的NotificationCompat进行构造final NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);builder.setContentTitle("微信");builder.setContentText("下载中");new Thread( new Runnable() &#123; @Override public void run() &#123; int incr; for (incr = 0; incr &lt;= 100; incr += 5) &#123; builder.setProgress(100, incr, false); builder.setContentInfo(incr + "%"); manger.notify(1, builder.build()); try &#123; Thread.sleep(1 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; builder.setContentText("下载完成") // 移除进度条 .setProgress(0, 0, false).setContentInfo(""); Notification notification = builder.build(); manger.notify(1, notification); &#125; &#125;).start(); 1234567891011121314151617181920212223242526272829303132//为了版本兼容 选择V7包下的NotificationCompat进行构造final NotificationCompat.Builder builder = new NotificationCompat.Builder(this);//setSmallIcon 通知上面的小图标builder.setSmallIcon(R.mipmap.ic_launcher);//setLargeIcon 通知消息上的大图标builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));//setAutoCancel 点击通知的清除按钮是否清除该消息（true/false）builder.setAutoCancel(true);builder.setContentTitle("微信");builder.setContentText("下载中");new Thread( new Runnable() &#123; @Override public void run() &#123; int incr; for (incr = 0; incr &lt;= 100; incr += 5) &#123; builder.setProgress(0, 0, true); manger.notify(2, builder.build()); try &#123; Thread.sleep(1 * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; builder.setContentText("下载完成") // 移除进度条 .setProgress(0, 0, false).setContentInfo(""); Notification notification = builder.build(); manger.notify(2, notification); &#125; &#125;).start(); BigTextStyle123456789101112131415161718192021NotificationCompat.Builder builder = new NotificationCompat.Builder(this);builder.setContentTitle("BigTextStyle");builder.setContentText("BigTextStyle演示示例");builder.setSmallIcon(R.mipmap.ic_launcher);builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));android.support.v4.app.NotificationCompat.BigTextStyle style = new android.support.v4.app.NotificationCompat.BigTextStyle();//bigText 给样式设置大文本内容style.bigText("这里是点击通知后要显示的正文，正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字正文很多字");//setBigContentTitle 给样式设置大文本的标题style.setBigContentTitle("点击后的标题");//SummaryText没什么用 可以不设置style.setSummaryText("末尾只一行的文字内容");//setStyle 将样式添加到通知builder.setStyle(style);builder.setAutoCancel(true);Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0);builder.setContentIntent(pIntent);builder.setDefaults(NotificationCompat.DEFAULT_ALL);Notification notification = builder.build();manger.notify(3, notification); InBoxStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("InboxStyle"); builder.setContentText("InboxStyle演示示例"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); android.support.v4.app.NotificationCompat.InboxStyle style = new android.support.v4.app.NotificationCompat.InboxStyle(); style.setBigContentTitle("BigContentTitle") .addLine("啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦啦") .addLine("哈哈哈哈哈") .addLine("嘻嘻嘻嘻") .addLine("嘿嘿嘿") .addLine("咦咦咦咦") .setSummaryText("SummaryText"); builder.setStyle(style); builder.setAutoCancel(true); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setDefaults(NotificationCompat.DEFAULT_ALL); Notification notification = builder.build(); manger.notify(4, notification); BigPictureStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("BigPictureStyle"); builder.setContentText("BigPicture演示示例"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setDefaults(NotificationCompat.DEFAULT_ALL); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); android.support.v4.app.NotificationCompat.BigPictureStyle style = new android.support.v4.app.NotificationCompat.BigPictureStyle(); style.setBigContentTitle("BigContentTitle"); style.setSummaryText("SummaryText"); style.bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.head)); builder.setStyle(style); builder.setAutoCancel(true); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setDefaults(NotificationCompat.DEFAULT_ALL); Notification notification = builder.build(); manger.notify(5, notification); HungUpStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("横幅通知"); builder.setContentText("请在设置通知管理中开启消息横幅提醒权限"); builder.setDefaults(NotificationCompat.DEFAULT_ALL); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); builder.setFullScreenIntent(pIntent, true); builder.setAutoCancel(true); Notification notification = builder.build(); manger.notify(6, notification); MediaStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setContentTitle("You Are Not Alone"); builder.setContentText("Michael Jackson"); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setDefaults(NotificationCompat.DEFAULT_ALL); //在锁定屏幕上显示控制，即使用户隐藏敏感内容(API&gt;=21) builder.setVisibility(Notification.VISIBILITY_PUBLIC); Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com")); PendingIntent pIntent = PendingIntent.getActivity(this, 1, intent, 0); builder.setContentIntent(pIntent); //addAction： 3个参数 图标、图标的标题、图标的动作 builder.addAction(android.R.drawable.ic_media_previous, "上一曲", null); builder.addAction(android.R.drawable.ic_media_pause, "暂停", null); builder.addAction(android.R.drawable.ic_media_play, "播放", pIntent); builder.addAction(android.R.drawable.ic_media_next, "下一曲", null); NotificationCompat.MediaStyle style = new NotificationCompat.MediaStyle(); style.setMediaSession(new MediaSessionCompat(this, "MediaSession", new ComponentName(MainActivity.this, Intent.ACTION_MEDIA_BUTTON), null).getSessionToken()); //CancelButton在5.0以下的机器有效 style.setCancelButtonIntent(pIntent); style.setShowCancelButton(true); //设置要现实在通知右方的图标 最多三个 style.setShowActionsInCompactView(2, 3); builder.setStyle(style); builder.setShowWhen(false); Notification notification = builder.build(); manger.notify(7, notification); RemoteViewsStyleNotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher);//小图标 RemoteViews remoteViews = new RemoteViews(this.getPackageName(), R.layout.remoteview_main); String title="Android Developer"; String content="developer.android.com"; remoteViews.setTextViewText(R.id.tv_title, title); remoteViews.setTextViewText(R.id.tv_content, content); builder.setContent(remoteViews); Notification notification = builder.build(); manger.notify(8, notification);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Material Design —— Snackbar]]></title>
      <url>%2F2016%2F05%2F11%2FAndroid-Material-Design-%E2%80%94Snackbar%2F</url>
      <content type="text"><![CDATA[本节介绍在Material Design中有趣的组件之一的Snackbar Snackbar对于一个反馈提供了一个轻量级的操作。它显示了一个简短的消息在移动设备屏幕的底部，或者大型设备的左下方。Snackbar出现在屏幕上所有的元素之上，并且同一时间有且只能让一个被显示。除了能像Toast消息之外还提供了action动作来相互作用。以下就对Snackbar几种不同的场景进行示例说明 1234Snackbarextends Objectjava.lang.Object ↳ android.support.design.widget.Snackbar 简易的Snackbar下面的语法是一个简易的snackbar make方法的作用接受3个参数，视图、显示的消息和消息显示的间隔时间。 间隔时间应该是LENGTH_SHORT, LENGTH_LONG 或者 LENGTH_INDEFINITE，当LENGTH_INDEFINITE 被使用，snackbar将会显示时间不定，除非手动滑动关闭或者有其他新的snackbar显示 1234Snackbar snackbar = Snackbar .make(linearLayout, "This is a simple snackbar", Snackbar.LENGTH_LONG); snackbar.show(); Snackbar动作回调您也可以使用的setAction（）方法作用于回调。当用户使用snackbar的时候，它允许我们执行某几个动作。 1234567891011Snackbar snackbar = Snackbar .make(coordinatorLayout, "Message is deleted", Snackbar.LENGTH_LONG) .setAction("UNDO", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar snackbar1 = Snackbar.make(coordinatorLayout, "Message is restored!", Snackbar.LENGTH_SHORT); snackbar1.show(); &#125; &#125;); snackbar.show(); 自定义SnackbarSnackbar 默认为白色文本颜色和#323232的背景颜色，你能够重写这些颜色 12345678910111213141516Snackbar snackbar = Snackbar .make(coordinatorLayout, "No internet connection!", Snackbar.LENGTH_LONG) .setAction("RETRY", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; &#125; &#125;); // Changing message text colorsnackbar.setActionTextColor(Color.RED); // Changing action button text colorView sbView = snackbar.getView();TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text);textView.setTextColor(Color.YELLOW);snackbar.show(); 创建新项目1、在Android Studio中 File ⇒ New Project 新建一个项目 2、打开builde.gradle文件添加design support支持依赖库 com.android.support:design:23.3.0 build.gradle 123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.3.0' compile 'com.android.support:design:23.3.0'&#125; activity_main.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/linearLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" android:orientation="vertical" tools:context="com.example.shoewann.snackbardemo.MainActivity"&gt; &lt;Button android:id="@+id/btnSimpleSnackbar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="30dp" android:text="Simple Snackbar" /&gt; &lt;Button android:id="@+id/btnActionCallback" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="With Action Callback" /&gt; &lt;Button android:id="@+id/btnCustomSnackbar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:text="Custom Color" /&gt;&lt;/LinearLayout&gt; MainActivity.java import android.graphics.Color; import android.os.Bundle; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.LinearLayout; import android.widget.TextView; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private android.widget.LinearLayout linearLayout; private android.widget.Button btnSimpleSnackbar; private android.widget.Button btnActionCallback; private android.widget.Button btnCustomSnackbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); } private void initData() { this.btnSimpleSnackbar.setOnClickListener(this); this.btnActionCallback.setOnClickListener(this); this.btnCustomSnackbar.setOnClickListener(this); } private void initView() { this.linearLayout = (LinearLayout) findViewById(R.id.linearLayout); this.btnSimpleSnackbar = (Button) findViewById(R.id.btnSimpleSnackbar); this.btnActionCallback = (Button) findViewById(R.id.btnActionCallback); this.btnCustomSnackbar = (Button) findViewById(R.id.btnCustomSnackbar); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btnSimpleSnackbar: Snackbar snackbar = Snackbar .make(linearLayout, "This is a simple snackbar", Snackbar.LENGTH_LONG); snackbar.show(); break; case R.id.btnActionCallback: Snackbar snackbar1 = Snackbar .make(linearLayout, "Message is deleted", Snackbar.LENGTH_LONG) .setAction("UNDO", new View.OnClickListener() { @Override public void onClick(View view) { Snackbar snackbar2 = Snackbar.make(linearLayout, "Message is restored!", Snackbar.LENGTH_SHORT); snackbar2.show(); } }); snackbar1.show(); break; case R.id.btnCustomSnackbar: Snackbar snackbar3 = Snackbar .make(linearLayout, "No internet connection!", Snackbar.LENGTH_LONG) .setAction("RETRY", new View.OnClickListener() { @Override public void onClick(View view) { } }); // Changing message text color snackbar3.setActionTextColor(Color.RED); // Changing action button text color View sbView = snackbar3.getView(); TextView textView = (TextView) sbView.findViewById(android.support.design.R.id.snackbar_text); textView.setTextColor(Color.YELLOW); snackbar3.show(); break; default: break; } } } Run and test the app.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中自定义Seekbar分段的方法]]></title>
      <url>%2F2016%2F05%2F11%2FAndroid%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89Seekbar%E5%88%86%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Android中自定义Seekbar分段的方法 在这里加入将一个Seekbar，平均分段为8段，每次拖动的距离相等 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243seekbar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; // TODO Auto-generated method stub Log.i(TAG, "----onStopTrackingTouch----"); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; // TODO Auto-generated method stub Log.i(TAG, "----onStartTrackingTouch----"); &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if (fromUser) &#123; float pro = seekBar.getProgress(); float max = seekBar.getMax(); float result = (pro / max) * 100; if (result == 0) &#123; seekBar.setProgress(0); &#125; else if (result &gt; 0 &amp;&amp; result &lt;= 12.5) &#123; seekBar.setProgress(25 / 2); &#125; else if (result &gt; 12.5 &amp;&amp; result &lt;= 25) &#123; seekBar.setProgress(25); &#125; else if (result &gt; 25 &amp;&amp; result &lt;= 37.5) &#123; seekBar.setProgress(25 + (25 / 2)); &#125; else if (result &gt; 37.5 &amp;&amp; result &lt;= 50) &#123; seekBar.setProgress(50); &#125; else if (result &gt; 50 &amp;&amp; result &lt;= 62.5) &#123; seekBar.setProgress(50 + (25 / 2)); &#125; else if (result &gt; 62.5 &amp;&amp; result &lt;= 75) &#123; seekBar.setProgress(75); &#125; else if (result &gt; 75 &amp;&amp; result &lt;= 87.5) &#123; seekBar.setProgress(75 + (25 / 2)); &#125; else if (result &gt; 87.5 &amp;&amp; result &lt;= 100) &#123; seekBar.setProgress(100); &#125; &#125; &#125; &#125;);]]></content>
    </entry>

    
  
  
</search>
